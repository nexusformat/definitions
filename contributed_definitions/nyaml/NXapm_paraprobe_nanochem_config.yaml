category: application
doc: |
  Application definition for a configuration file of the paraprobe-nanochem tool.
  
  This tool is part of the paraprobe-toolbox. Inspect :ref:`NXapm_paraprobe_tool_config` for details.
symbols:
  doc: |
    The symbols used in the schema to specify e.g. dimensions of arrays.
  n_ityp_deloc_cand: |
    How many iontypes does the delocalization filter specify.
  n_grid: |
    How many grid_resolutions values.
  n_var: |
    How many kernel_variance values.
  n_control_pts: |
    How many disjoint control points are defined.
  n_fct_filter_cand: |
    How many iontypes does the interface meshing iontype filter specify.
  n_fct_iterations: |
    How many DCOM iterations.
  n_ivec_max: |
    Maximum number of atoms per molecular ion.
  n_rois: |
    Number of cylinder ROIs to place for oned_profile if no feature mesh is used.
type: group
NXapm_paraprobe_nanochem_config(NXobject):
  (NXentry):
    exists: [min, 1, max, 1]
    definition(NX_CHAR):
      \@version(NX_CHAR):
      enumeration: [NXapm_paraprobe_nanochem_config]
    delocalization(NXapm_paraprobe_tool_config):
      exists: [min, 0, max, 1]
      doc: |
        Discretization and distributing of the ion point cloud on a 3D grid
        to enable continuum-scale analyses.
        
        By default, the tool computes a full kernel density estimation of decomposed
        ions to create one discretized field for each element.
        
        One delocalization task configures a parameter sweep with at least one
        delocalization. The total number of runs depends on the number of
        grid_resolution and kernel_variance values. For example, setting two grid_resolutions
        and three kernel_variance will compute six runs. Two sets of three with the first set using
        the first grid_resolutions and in sequence the kernel_variance respectively.
      #  Although, this uses an efficient multithreaded algorithm the computation is costly.
      #  Therefore, it can be advantageous for users to load an already computed delocalization.
      #  This can be achieved with the load_existent option.
      (NXidentifier):
        exists: optional
      analysis_identifier(NX_UINT):
        exists: recommended
      reconstruction(NXserialized):
        type(NX_CHAR):
        path(NX_CHAR):
        checksum(NX_CHAR):
        algorithm(NX_CHAR):
        position(NX_CHAR):
        mass_to_charge(NX_CHAR):
      ranging(NXserialized):
        type(NX_CHAR):
        path(NX_CHAR):
        checksum(NX_CHAR):
        algorithm(NX_CHAR):
        ranging_definitions(NX_CHAR):
      surface(NXserialized):
        doc: |
          A precomputed triangulated surface mesh representing a model (of the surface)
          of the edge of the dataset. This model can be used to detect and control
          various sources of bias in the analyses.
        type(NX_CHAR):
        path(NX_CHAR):
        checksum(NX_CHAR):
        algorithm(NX_CHAR):
        vertices(NX_CHAR):
          doc: |
            Absolute path in the (HDF5) file that points to the array
            of vertex positions for the triangles in that triangle_set.
        indices(NX_CHAR):
          doc: |
            Absolute path in the (HDF5) file that points to the array
            of vertex indices for the triangles in that triangle_set.
      surface_distance(NXserialized):
        exists: recommended
        doc: |
          Distance between each ion and triangulated surface mesh.
        type(NX_CHAR):
        path(NX_CHAR):
        checksum(NX_CHAR):
        algorithm(NX_CHAR):
        distance(NX_CHAR):
      spatial_filter(NXspatial_filter):
        windowing_method(NX_CHAR):
        hexahedron_set(NXcg_hexahedron_set):
          exists: optional
          dimensionality(NX_POSINT):
          cardinality(NX_POSINT):
          identifier_offset(NX_INT):
          hexahedra(NXcg_face_list_data_structure):
            vertices(NX_UINT):
        cylinder_set(NXcg_cylinder_set):
          exists: optional
          dimensionality(NX_POSINT):
          cardinality(NX_POSINT):
          identifier_offset(NX_INT):
          center(NX_NUMBER):
          height(NX_NUMBER):
          radii(NX_NUMBER):
        ellipsoid_set(NXcg_ellipsoid_set):
          exists: optional
          dimensionality(NX_POSINT):
          cardinality(NX_POSINT):
          identifier_offset(NX_INT):
          center(NX_NUMBER):
          half_axes_radii(NX_NUMBER):
          orientation(NX_NUMBER):
        polyhedron_set(NXcg_polyhedron_set):
          exists: optional
          # TODO
        bitmask(NXcs_filter_boolean_mask):
          exists: optional
          number_of_objects(NX_UINT):
          bitdepth(NX_UINT):
          mask(NX_UINT):
          # leave open if scalar or matrix
          #   dim: (i,)
          # identifier(NX_UINT):
      evaporation_id_filter(NXsubsampling_filter):
        exists: optional
        min_incr_max(NX_INT):
      iontype_filter(NXmatch_filter):
        exists: optional
        method(NX_CHAR):
        match(NX_NUMBER):
      hit_multiplicity_filter(NXmatch_filter):
        exists: optional
        method(NX_CHAR):
        match(NX_NUMBER):
      # config
      method(NX_CHAR):
        doc: |
          Compute delocalization or load an existent one from input.
        enumeration: [compute, load_existent]
      input(NXserialized):
        doc: |
          Serialized result of an already computed delocalization which is for performance
          reasons here just loaded and not computed again.
        type(NX_CHAR):
        path(NX_CHAR):
        checksum(NX_CHAR):
        algorithm(NX_CHAR):
        results(NX_CHAR):
          doc: |
            Absolute path in the (HDF5) file that points to the group within which
            individual delocalization results are stored.
          # TODO: add more descriptions
      nuclide_whitelist(NX_UINT):
        doc: |
          Matrix of nuclides representing how iontypes should be accounted for during
          the delocalization. This is the most general approach to define if and how many
          times an ion is to be counted. The tool performs a so-called atomic decomposition
          of all iontypes, i.e. the tool analyses from how many atoms of each nuclide
          or element respectively an (molecular) ion is built from.
          
          Taking the hydroxonium H3O+ molecular ion as an example:
          It contains hydrogen and oxygen atoms. The multiplicity of hydrogen
          is three whereas that of oxygen is one. Therefore, the respective atomic decomposition
          analysis prior to the iso-surface computation adds three hydrogen counts for each
          H3O+ ion.
          
          This is a practical solution which accepts that on the one hand not every bond is
          broken during an atom probe experiment but also that ions may react further during
          their flight to the detector. The exact details depend on the local field conditions,
          quantum mechanics of possible electron transfer and thus the detailed trajectory
          of the system and its electronic state.
          
          The detection of molecular ions instead of always single atom ions only is the
          reason that an atom probe experiment tells much about field evaporation physics
          but also faces an inherent loss of information with respect to the detailed spatial
          arrangement that is independent of other imprecisions such as effect of limited
          accuracy of reconstruction protocols and their parameterization.
          
          Unused values in each row of the matrix are nullified.
          Nuclides are identified as hashed nuclide (see :ref:`NXion`) for further details.
        unit: NX_UNITLESS
        dim: (n_ityp_deloc_cand, n_ivec_max)
      grid_resolution(NX_FLOAT):
        doc: |
          Array of edge lengths of the cubic cells used for discretizing the reconstructed dataset
          on a cuboidal 3D grid (:ref:`NXcg_grid`). The tool performs as many delocalization
          computations as values are specified in grid_resolution.
        unit: NX_LENGTH
        dim: (n_grid,)
      kernel_size(NX_UINT):
        doc: |
          Half the width of a :math:`{(2 \cdot n + 1)}^3` cubic kernel of cubic voxel
          beyond which the Gaussian Ansatz function will be truncated. Intensity outside
          the kernel is factorized into the kernel via a normalization procedure.
        unit: NX_UNITLESS
      kernel_variance(NX_FLOAT):
        doc: |
            Array of variance values :math:`\sigma` of the Gaussian Ansatz kernel
            (:math:`\sigma_x := \sigma`, :math:`\sigma_x = \sigma_y = 2 \cdot \sigma_z`).
            The tool performs as many delocalization computations as values are specified
            in kernel_variance.
        unit: NX_LENGTH
        dim: (n_var,)
      normalization(NX_CHAR):
        doc: |
          How should the results of the kernel-density estimation be normalized into quantities.
          By default, the tool computes the total number (intensity) of ions or elements.
          Alternatively, the tool can compute the total intensity, the composition,
          or the concentration of the ions/elements specified by the nuclide_whitelist.
        enumeration: [none, composition, concentration]
      has_scalar_fields(NX_BOOLEAN):
        doc: |
          Specifies if the tool should report the delocalization 3D field values.
      isosurfacing(NXprocess):
        exists: [min, 0, max, 1]
        doc: |
          Configuration of the set of iso-surfaces to compute using that delocalization.
          Such iso-surfaces are the starting point for a reconstruction of so-called objects or
          (microstructual) features. Examples of scientific relevant are (line features e.g. dislocations
          poles, surface features such as interfaces, i.e. phase and grain boundaries, or volumetric
          features such as precipitates.
          Users should be aware that reconstructed datasets in atom probe are a model and may face
          inaccuracies and artifacts that can be mistaken incorrectly as microstructural features.
        edge_method(NX_CHAR):
          doc: |
            As it is detailed in `M. KÃ¼hbach et al. <https://arxiv.org/abs/2205.13510>`_, the handling of
            triangles at the surface (edge) of the dataset requires special attention especially for
            composition-normalized delocalization. Here, it is possible that the composition
            increases towards the edge of the dataset because the quotient of two numbers
            that are both smaller than one is larger instead of smaller than the counter.
            
            By default, the tool uses a modified marching cubes algorithm of Lewiner et al.
            which detects if voxels face such a situation. In this case, no triangles are generated
            for such voxels.
            
            Alternatively, keep_edge_triangles instructs the tool to not remove triangles at the
            edge of the dataset at the cost of bias. When using this keep_edge_triangles users
            should understand that all features in contact with the edge of the dataset get usually
            artificial enlarged. Consequently, triangulated surface meshes of these objects are
            closed during the marching. However, this closure is artificial and can biased shape
            analyses for those objects. This also holds for such practices that are offered in
            proprietary software like IVAS / AP Suite. The situation is comparable to analyses
            of grain shapes via orientation microscopy from electron microscopy or X-ray
            diffraction tomography. Features at the edge of the dataset may have not been
            captured fully.
            
            Thanks to collaboration with V. V. Rielli and S. Primig from the Sydney atom probe group,
            paraprobe-nanochem implements a complete pipeline to process features at the edge of the
            dataset. Specifically, these are modelled and replaced with closed polyhedral objects using
            an iterative mesh and hole-filling procedures with fairing operations.
            
            The tool bookkeeps such objects separately to lead the decision whether or not to
            consider these objects to the user. Users should be aware that results from fairing operations
            should be compared to results from analyses where all objects at the edge
            of the dataset have been removed. Furthermore, users should be careful with overestimating
            the statistical significance of their dataset especially when using atom probe when they
            use their atom probe result to compare different descriptors. Even though a dataset may
            deliver statistically significant results for compositions, this does not necessarily mean that
            same dataset will also yield statistically significant and insignificantly biased results for
            3D object analyses!
            
            Being able to quantify these effects and making atom probers aware of these subtleties
            was one of the main reasons why the paraprobe-nanochem tool was implemented.
          enumeration: [default, keep_edge_triangles]
        edge_threshold(NX_FLOAT):
          doc: |
            The ion-to-surface distance that is used in the analyses of features to identify whether
            these are laying inside the dataset or close to the surface (edge) of the dataset.
            
            If an object has at least one ion with an ion-to-surface-distance below this threshold,
            the object is considered close to the edge of the dataset. The tool uses a distance-based
            approach to solve the in general complicated and involved treatment of computing
            volumetric intersections between closed 2-manifolds that are not necessarily convex.
            The main practical reason is that such computational geometry analyses face numerical
            robustness issues as a consequence of which a mesh can be detected as being completely
            inside another mesh although in reality it is only :math:`\epsilon`-close only, i.e. almost
            touching only the edge (e.g. from inside).
            
            Practically, humans would likely still state in such case that the object is close to the
            edge of the dataset; however mathematically the object is indeed completely inside.
            In short, a distance-based approach is rigorous and flexible.
          unit: NX_LENGTH
        phi(NX_FLOAT):
          doc: |
            Iso-contour values. For each value, the tool computes an iso-surface and performs
            subsequent analyses for each iso-surface. The unit depends on the choice for the
            normalization of the accumulated ion intensity values per voxel:
            
            * total, total number of ions, irrespective their iontype
            * candidates, total number of ions with type in the isotope_whitelist.
            * composition, candidates but normalized by composition, i.e. at.-%
            * concentration, candidates but normalized by voxel volume, i.e. ions/nm^3
            
          unit: NX_ANY
        has_triangle_soup(NX_BOOLEAN):
          doc: |
            Specifies if the tool should report the triangle soup which represents each triangle of the
            iso-surface complex. The resulting set of triangles is colloquially referred to as a soup
            because different sub-set may not be connected.
            
            Each triangle is reported with an ID specifying to which triangle cluster (with IDs starting at zero)
            the triangle belongs. The clustering of triangles within the soup is performed with a
            modified DBScan algorithm.
        has_object(NX_BOOLEAN):
          doc: |
            Specifies if the tool should analyze for each cluster of triangles how they can be combinatorially
            processed to describe a closed polyhedron. Such a closed polyhedron (not-necessarily convex!)
            can be used to describe objects with relevance in the microstructure.
            
            Users should be aware that the resulting mesh does not necessarily represent the original precipitate.
            In fact, inaccuracies in the reconstructed positions cause inaccuracies in all downstream processing
            operations. Especially the effect on one-dimensional spatial statistics like nearest neighbor correlation
            functions were discussed in the literature `B. Gault et al. <https://doi.org/10.1017/S1431927621012952>`_.
            
            In continuation of these thoughts, this applies also to reconstructed objects.
            A well-known example is the discussion of shape deviations of scandium-rich precipitates in aluminium alloys
            which in reconstructions may appear as ellipsoids although they should be indeed almost spherical
            provided their size is larger than the atomic length scale.
        has_object_geometry(NX_BOOLEAN):
          doc: |
            Specifies if the tool should report a triangulated surface mesh for each identified closed polyhedron.
            It is common that a marching cubes algorithm creates iso-surfaces with a fraction of tiny sub-complexes
            (e.g. small isolated tetrahedra).
            
            These can be small tetrahedra/polyhedra about the center of a voxel of the support grid
            on which marching cubes operates. Such objects may not contain an ion; especially when considering
            that delocalization procedures smoothen the positions of the ions. Although these small objects are
            interesting from a numerical point of view, scientists may argue they are not worth to be reported because
            a microstructural feature should contain at least a few atoms to become relevant.
            Therefore, paraprobe-nanochem by default does not report closed objects which bound a volume
            that contains no ion.
        has_object_properties(NX_BOOLEAN):
          doc: |
            Specifies if the tool should report properties of each closed polyhedron, such as volume and other details.
        has_object_obb(NX_BOOLEAN):
          doc: |
            Specifies if the tool should report for each closed polyhedron an approximately optimal bounding box
            fitted to all triangles of the surface mesh of the object and ion positions inside or on the surface of the mesh.
            This bounding box informs about the closed object's shape (aspect ratios).
            
            Users should be aware that the choice of the algorithm to compute the bounding box can have an
            effect on aspect ratio statistics. It is known that computing the true optimal bounding box of in 3D
            is an :math:`\mathcal{O}^3`-time-complex task. The tool uses well-established approximate algorithms
            of the Computational Geometry Algorithms Library (CGAL).
        has_object_ions(NX_BOOLEAN):
          doc: |
            Specifies if the tool should report for each closed polyhedron all evaporation IDs of those ions which
            lay inside or on the boundary of the polyhedron. This information is used by the paraprobe-intersector
            tool to infer if two objects share common ions, which is then understood as that the two objects intersect.
            
            Users should be aware that two arbitrarily closed polyhedra in three-dimensional space can intersect
            but not share a common ion. In fact, the volume bounded by the polyhedron has sharp edges and flat
            face(t)s. When taking two objects, an edge of one object may for instance pierce into the surface of
            another object. In this case the objects partially overlap / intersect volumetrically; however this piercing
            might be so small or happening in the volume between two reconstructed ion positions. Consequently,
            sharing ions is a sufficient but not a necessary condition for interpreting (volumetric) intersections
            between objects.
            
            Paraprobe-intersector implements a rigorous alternative to handle such intersections using a tetrahedralization
            of closed objects. However, in many practical cases, we found through examples that there are polyhedra (especially when they are non-convex and have almost point-like) connected channels, where
            tetrahedralization libraries have challenges dealing with. In this case, checking intersections
            via shared_ions is a more practical alternative.
        has_object_edge_contact(NX_BOOLEAN):
          doc: |
            Specifies if the tool should report if a (closed) object has contact with the surface aka edge of the dataset.
            For this the tool currently inspects if the shortest distance between the set of triangles of the triangulated
            surface mesh and the triangles of the edge model is larger than edge_threshold.
            If this is the case, the object is assumed to be deeply embedded in the interior of the dataset.
            Otherwise, the object is considered to have an edge contact, i.e. it shape is likely affected by the edge.
        has_proxy(NX_BOOLEAN):
          doc: |
            Specifies if the tool should analyze a closed polyhedron (aka proxy) for each cluster of triangles whose
            combinatorial analysis according to has_object returned that the object is not a closed polyhedron.
            Such proxies are closed via iterative hole-filling, mesh refinement, and fairing operations.
            
            Users should be aware that the resulting mesh does not necessarily represent the original feature.
            In most cases objects, precipitates in atom probe end up as open objects because they have been
            clipped by the edge of the dataset. Using a proxy is in this case a strategy to still be able to account
            for these objects. However, users should make themselves familiar with the consequences and
            potential biases which this can introduce into the analysis.
        has_proxy_geometry(NX_BOOLEAN):
          doc: |
            Like has_object_geometry but for the proxies.
        has_proxy_properties(NX_BOOLEAN):
          doc: |
            Like has_object_properties but for the proxies.
        has_proxy_obb(NX_BOOLEAN):
          doc: |
            Like has_object_obb but for the proxies.
        has_proxy_ions(NX_BOOLEAN):
          doc: |
            Like has_object_ions but for the proxies.
        has_proxy_edge_contact(NX_BOOLEAN):
          doc: |
            Like has_object_edge_contact but for the proxies.
        has_object_proxigram(NX_BOOLEAN):
          doc: |
            Specifies if the tool should report for each closed object a (cylindrical) region-of-interest (ROI) that gets
            placed, centered, and aligned with the local normal for each triangle of the object.
        has_object_proxigram_edge_contact(NX_BOOLEAN):
          doc: |
            Specifies if the tool should report for each ROI that was placed at a triangle of each object if this ROI intersects
            with the edge the dataset. Currently, the tool supports cylindrical ROIs. A computational geometry test is
            performed to check for a possible intersection of each ROI with the triangulated surface mesh that is defined
            via surface. Results of this cylinder-set-of-triangles intersection are interpreted as follows:
            If the cylinder intersects with at least one triangle of the surface (mesh) the ROI is assumed to make edge contact.
            Otherwise, the ROI is assumed to make  no edge contact.
            
            Users should note that this approach does not work if the ROI is laying completely outside the dataset as also
            in this case the cylinder intersects with any triangle. However, for atom probe this case is practically irrelevant
            provided constructions such as alpha shapes or alpha wrappings (such as paraproeb-surfacer does) about the
            ions of the entire reconstructed volume are used.
        # has_object_mesh_smoothing(NX_BOOLEAN):
        #   doc: Specifies if the tool should post-process each mesh to improve the mesh quality.
        # mesh_smoothing(NXprocess):
        # NEW ISSUE: here we need to specify how the meshes were smoothened

    interface_meshing(NXapm_paraprobe_tool_config):
      exists: [min, 0, max, 1]
      doc: |
        Use a principle component analysis (PCA) to mesh a single free-standing interface patch within
        the reconstructed volume that is decorated by ions of specific iontypes (e.g. solute atoms).
        
        Interface_meshing is a typical starting point for the quantification of Gibbsian interfacial excess
        in cases when closed objects constructed from patches e.g. iso-surfaces are not available or
        when there is no substantial or consistently oriented concentration gradients across an interface
        patch. The functionality can also be useful when the amount of latent crystallographic information
        within the point cloud is insufficient or when combined with interface_meshing based on ion density
        traces in field-desorption maps (see `Y. Wei et al. <https://doi.org/10.1371/journal.pone.0225041>`_
        and `A. Breen et al. <https://github.com/breen-aj/detector>`_ for details).
        
        Noteworthy to mention is that the method used is conceptually similar to the work of `Z. Peng et al. <https://doi.org/10.1017/S1431927618016112>`_ and related work (DCOM algorithm) by `P. Felfer et al. <https://doi.org/10.1016/j.ultramic.2015.06.002>`_. Compared to these implementations
        paraprobe-nanochem uses inspection functionalities which detect potential geometric
        inconsistencies or self-interactions of the evolved DCOM mesh.
      (NXidentifier):
        exists: optional
      analysis_identifier(NX_UINT):
        exists: recommended
      reconstruction(NXserialized):
        type(NX_CHAR):
        path(NX_CHAR):
        checksum(NX_CHAR):
        algorithm(NX_CHAR):
        position(NX_CHAR):
        mass_to_charge(NX_CHAR):
      ranging(NXserialized):
        type(NX_CHAR):
        path(NX_CHAR):
        checksum(NX_CHAR):
        algorithm(NX_CHAR):
        ranging_definitions(NX_CHAR):
      surface(NXserialized):
        exists: optional
        doc: |
          A precomputed triangulated surface mesh representing a model (of the surface)
          of the edge of the dataset. This model can be used to detect and control
          various sources of bias in the analyses.
        type(NX_CHAR):
        path(NX_CHAR):
        checksum(NX_CHAR):
        algorithm(NX_CHAR):
        vertices(NX_CHAR):
          doc: |
            Absolute path in the (HDF5) file that points to the array
            of vertex positions for the triangles in that triangle_set.
        indices(NX_CHAR):
          doc: |
            Absolute path in the (HDF5) file that points to the array
            of vertex indices for the triangles in that triangle_set.
      spatial_filter(NXspatial_filter):
        windowing_method(NX_CHAR):
        hexahedron_set(NXcg_hexahedron_set):
          exists: optional
          dimensionality(NX_POSINT):
          cardinality(NX_POSINT):
          identifier_offset(NX_INT):
          hexahedra(NXcg_face_list_data_structure):
            vertices(NX_UINT):
        cylinder_set(NXcg_cylinder_set):
          exists: optional
          dimensionality(NX_POSINT):
          cardinality(NX_POSINT):
          identifier_offset(NX_INT):
          center(NX_NUMBER):
          height(NX_NUMBER):
          radii(NX_NUMBER):
        ellipsoid_set(NXcg_ellipsoid_set):
          exists: optional
          dimensionality(NX_POSINT):
          cardinality(NX_POSINT):
          identifier_offset(NX_INT):
          center(NX_NUMBER):
          half_axes_radii(NX_NUMBER):
          orientation(NX_NUMBER):
        polyhedron_set(NXcg_polyhedron_set):
          exists: optional
          # TODO
        bitmask(NXcs_filter_boolean_mask):
          exists: optional
          number_of_objects(NX_UINT):
          bitdepth(NX_UINT):
          mask(NX_UINT):
          # leave open if scalar or matrix
          #   dim: (i,)
          # identifier(NX_UINT):
      evaporation_id_filter(NXsubsampling_filter):
        exists: optional
        min_incr_max(NX_INT):
      iontype_filter(NXmatch_filter):
        exists: optional
        method(NX_CHAR):
        match(NX_NUMBER):
      hit_multiplicity_filter(NXmatch_filter):
        exists: optional
        method(NX_CHAR):
        match(NX_NUMBER):
      # config
      initialization(NX_CHAR):
        doc: |
          How is the PCA initialized:
          
          * default, means based on segregated solutes in the ROI
          * control_point_file, means based on reading an external list of
            control points, currently coming from the Leoben APT_Analyzer.
          
          The control_point_file is currently expected with a specific format.
          The Leoben group lead by L. Romaner has developed a GUI tool `A. Reichmann et al. <https://github.com/areichm/APT_analyzer>`_ creates a control_point_file that
          can be parsed by paraprobe-parmsetup-nanochem to match the here required
          formatting in control_points.
        enumeration: [default, control_point_file]
      control_point(NXserialized):
        doc: |
          Details about the control point file used.
        type(NX_CHAR):
        path(NX_CHAR):
        checksum(NX_CHAR):
        algorithm(NX_CHAR):
        control_points(NX_CHAR):
          doc: |
            X, Y, Z position matrix of disjoint control points.
      method(NX_CHAR):
        doc: |
          Method used for identifying and refining the location of the interface. Currently,
          paraprobe-nanochem implements a PCA followed by an iterative loop of isotropic
          mesh refinement and DCOM step(s), paired with self-intersection detection.
        enumeration: [pca_plus_dcom]
      decoration_filter(NXmatch_filter):
        doc: |
          Specify those nuclides which the tool should inspect iontypes for if they contain such nuclides.
          If this is the case ions of such type are taken with the number of nuclides of this multiplicity found.
          The atoms of these ions are assumed to serve as useful markers for locating the interface and
          refining the interface mesh.
        method(NX_CHAR):
          enumeration: [whitelist]
        match(NX_UINT):
          doc: |
            Array of nuclide iontypes to filter.
          unit: NX_UNITLESS
          dim: (n_fct_filter_cand, n_ivec_max)
      number_of_iterations(NX_UINT):
        doc: |
          How many times should the DCOM and mesh refinement be applied?
        unit: NX_UNITLESS
      target_edge_length(NX_FLOAT):
        doc: |
          Array of decreasing positive not smaller than one nanometer real values
          which specify how the initial triangles of the mesh should be iteratively
          refined by edge splitting and related mesh refinement operations.
        unit: NX_LENGTH
        dim: (n_fct_iterations,)
      target_dcom_radius(NX_FLOAT):
        doc: |
          Array of decreasing positive not smaller than one nanometer real values
          which specify the radius of the spherical region of interest within which the
          DCOM algorithm decides for each vertex how the vertex might be relocated.
          
          The larger it is the DCOM radius in relation to the target_edge_length the more
          likely it becomes that vertices will be relocated so substantially that triangle
          self-intersections may occur. The tool detects these and stops in a controlled
          manner so that the user can repeat the analyses with using a different parameterization.
        unit: NX_LENGTH
        dim: (n_fct_iterations,)
      target_smoothing_step(NX_UINT):
        doc: |
          Array of integers which specify for each DCOM step how many times the mesh
          should be iteratively smoothened. Users should be aware that all three arrays
          target_edge_length, target_dcom_radius, and target_smoothing_step are interpreted
          in the same sequence, i.e. the zeroth entry of each array specifies the respective
          parameter values to be used in the first DCOM iteration. The first entry of each array
          those for the second DCOM iteration and so on and so forth.
        unit: NX_UNITLESS
        dim: (n_fct_iterations,)

    oned_profile(NXapm_paraprobe_tool_config):
      exists: [min, 0, max, 1]
      doc: |
        Analysis of one-dimensional profiles in ROIs placed in the dataset.
        Such analyses are useful for quantifying interfacial excess or for
        performing classical composition analyses.
        
        The tool will test for each ROIs if it is completely embedded in the dataset.
        Specifically, each such test evaluates if the ROI cuts at least one triangle
        of the triangulated surface mesh that is referred to by surface.
        If this is the case the ROI is marked as one close to the surface
        and not analyzed further. Otherwise, the ROI is marked as one far
        from the surface and processed further.
        
        For each ROI the tool computes atomically decomposed profiles.
        This means, molecular ions are splitted into nuclides as many times as
        their respective multiplicity. For each processed ROI the tool stores
        a sorted list of signed distance values to enable post-processing with
        other software like e.g. reporter to perform classical
        Krakauer/Seidman-style interfacial excess analyses.
        
        Users should be aware that the latter intersection analysis is not
        a volumetric intersection analysis. Given that the triangulated mesh
        referred to in surface is not required to mesh neither a watertight
        nor convex polyhedron a rigorous testing of volumetric intersection
        is much more involved. If the mesh is watertight one could use split
        the task in first tessellating the mesh into convex polyhedra (e.g.
        tetrahedra and apply a volumetric intersection method like the
        Gilbert-Johnson-Keerthi algorithm (GJK). In cases when the mesh is not
        even watertight distance-based segmentation in combination with again
        intersection of triangles and convex polyhedra is a robust but currently
        not implemented method to quantify intersections.
      (NXidentifier):
        exists: optional
      analysis_identifier(NX_UINT):
        exists: recommended
      reconstruction(NXserialized):
        type(NX_CHAR):
        path(NX_CHAR):
        checksum(NX_CHAR):
        algorithm(NX_CHAR):
        position(NX_CHAR):
        mass_to_charge(NX_CHAR):
      ranging(NXserialized):
        type(NX_CHAR):
        path(NX_CHAR):
        checksum(NX_CHAR):
        algorithm(NX_CHAR):
        ranging_definitions(NX_CHAR):
      surface(NXserialized):
        exists: optional
        doc: |
          A precomputed triangulated surface mesh representing a model (of the surface)
          of the edge of the dataset. This model can be used to detect and control
          various sources of bias in the analyses.
        type(NX_CHAR):
        path(NX_CHAR):
        checksum(NX_CHAR):
        algorithm(NX_CHAR):
        vertices(NX_CHAR):
          doc: |
            Absolute path in the (HDF5) file that points to the array
            of vertex positions for the triangles in that triangle_set.
        indices(NX_CHAR):
          doc: |
            Absolute path in the (HDF5) file that points to the array
            of vertex indices for the triangles in that triangle_set.
      surface_distance(NXserialized):
        exists: recommended
        doc: |
          Distance between each ion and triangulated surface mesh.
        type(NX_CHAR):
        path(NX_CHAR):
        checksum(NX_CHAR):
        algorithm(NX_CHAR):
        distance(NX_CHAR):
          doc: |
            Absolute path in the (HDF5) file that points to the distance values.
            The tool assumes that the values are stored in the same order as
            points (ions).
      feature(NXserialized):
        doc: |
          A precomputed triangulated mesh of the feature representing a model of the
          interface at which to place ROIs to profile. This can be the mesh of an
          interface as returned e.g. by a previous interface_meshing task or the
          mesh of an iso-surface from a previous delocalization task.
        type(NX_CHAR):
        path(NX_CHAR):
        checksum(NX_CHAR):
        algorithm(NX_CHAR):
        vertices(NX_CHAR):
          doc: |
            Absolute HDF5 path to the dataset that specifies the array of vertex positions.
        indices(NX_CHAR):
          doc: |
            Absolute HDF5 path to the dataset that specifies the array of facet indices
            which refer to vertices.
        facet_normals(NX_CHAR):
          doc: |
            Absolute HDF5 path to the dataset that  specifies the array of facet signed unit normals.
        vertex_normals(NX_CHAR):
          doc: |
            Absolute HDF5 path to the dataset that specifies the array of vertex signed unit normals.
        # triangulated surface meshes are only approximations to eventually curved shape of objects
        # consequently, vertex and facet normals typically differ, the former are typically interpolated
        # from normals of neighboring facets, type of weighting schemes can affect results quantitatively
        patch_filter(NXmatch_filter):
          exists: optional
          doc: |
            If interface_model is isosurface this filter can be used to restrict the analysis to specific
            patches of an iso-surface.
          method(NX_CHAR):
          match(NX_NUMBER):
      feature_distance(NXserialized):
        exists: recommended
        doc: |
          To enable an additional filtration of specific parts of the feature
          mesh it is recommended to feed precomputed distances of each ion to
          the triangles of the feature mesh.
        type(NX_CHAR):
        path(NX_CHAR):
        checksum(NX_CHAR):
        algorithm(NX_CHAR):
        distance(NX_CHAR):
          doc: |
            Absolute path in the (HDF5) file that points to the distance values.
            The tool assumes that the values are stored in the same order as
            points (ions).
      spatial_filter(NXspatial_filter):
        windowing_method(NX_CHAR):
        hexahedron_set(NXcg_hexahedron_set):
          exists: optional
          dimensionality(NX_POSINT):
          cardinality(NX_POSINT):
          identifier_offset(NX_INT):
          hexahedra(NXcg_face_list_data_structure):
            vertices(NX_UINT):
        cylinder_set(NXcg_cylinder_set):
          exists: optional
          dimensionality(NX_POSINT):
          cardinality(NX_POSINT):
          identifier_offset(NX_INT):
          center(NX_NUMBER):
          height(NX_NUMBER):
          radii(NX_NUMBER):
        ellipsoid_set(NXcg_ellipsoid_set):
          exists: optional
          dimensionality(NX_POSINT):
          cardinality(NX_POSINT):
          identifier_offset(NX_INT):
          center(NX_NUMBER):
          half_axes_radii(NX_NUMBER):
          orientation(NX_NUMBER):
        polyhedron_set(NXcg_polyhedron_set):
          exists: optional
          # TODO
        bitmask(NXcs_filter_boolean_mask):
          exists: optional
          number_of_objects(NX_UINT):
          bitdepth(NX_UINT):
          mask(NX_UINT):
          # leave open if scalar or matrix
          #   dim: (i,)
          # identifier(NX_UINT):
      evaporation_id_filter(NXsubsampling_filter):
        exists: optional
        min_incr_max(NX_INT):
      iontype_filter(NXmatch_filter):
        exists: optional
        method(NX_CHAR):
        match(NX_NUMBER):
      hit_multiplicity_filter(NXmatch_filter):
        exists: optional
        method(NX_CHAR):
        match(NX_NUMBER):
      # config
      user_defined_roi(NXobject):
        exists: optional
        doc: |
          As an alternative mode the tool can be instructed to place ROIs
          at specific locations into the dataset. This is the programmatic
          equivalent to the classical approach in atom probe to place ROIs
          for composition analyses via positioning and rotating them via
          a graphical user interface (such as in IVAS / AP Suite).
        cylinder_set(NXcg_cylinder_set):
          # dimensionality(NX_POSINT):
          # cardinality(NX_POSINT):
          identifier_offset(NX_INT):
          center(NX_NUMBER):
            dim: (n_rois, 3)
          height(NX_NUMBER):
            dim: (n_rois, 3)
          radii(NX_NUMBER):
            dim: (n_rois,)
        # could add other shapes in the future if necessary
        # but cylinders are most frequently used
      distancing_model(NX_CHAR):
        doc: |
          Which type of distance should be reported for the profile.
        enumeration: [project_to_triangle_plane]  # ion_to_feature
      roi_orientation(NX_CHAR):
        doc: |
          For each ROI, along which direction should the cylindrical ROI
          be oriented if ROIs are placed at triangles of the feature mesh.
        enumeration: [triangle_outer_unit_normal]  # angularly_geodesic_sphere
      roi_cylinder_height(NX_FLOAT):
        doc: |
          For each ROI, how high (projected onto the cylinder axis) should
          the cylindrical ROI be if ROIs are placed at triangles
          of the feature mesh.
        unit: NX_LENGTH
      roi_cylinder_radius(NX_FLOAT):
        doc: |
          For each ROI, how wide (in radius) should the cylindrical ROI
          be if ROIs are placed at triangles of the feature mesh.
        unit: NX_LENGTH

    common(NXapm_paraprobe_tool_common): 
      status(NX_CHAR):
      programID(NXprogram):
        exists: [min, 1, max, infty]
        program(NX_CHAR):
          \@version(NX_CHAR):
      profiling(NXcs_profiling):
        exists: recommended
        start_time(NX_DATE_TIME):
        end_time(NX_DATE_TIME):
        total_elapsed_time(NX_FLOAT):
        current_working_directory(NX_CHAR):
