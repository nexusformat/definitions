category: application
doc: |
  Application definition for atom probe and field ion microscopy experiments.
symbols:
  doc: |
    The symbols used in the schema to specify e.g. dimensions of arrays.
  p: |
    Number of pulses collected in between start_time and end_time resolved by an
    instance of :ref:`NXevent_data_apm`. If this is not defined, p is the number of
    ions included in the reconstructed volume if the application definition is used
    to store results of an already reconstructed datasets.
  n: |
    Number of ions spatially filtered from results of the hit_finding algorithm
    from which an instance of a reconstructed volume has been generated.
    These ions get new identifier assigned in the process (the so-called
    evaporation_identifier). This identifier must not be confused with
    the pulse_identifier.
type: group
NXapm(NXobject):
  (NXentry):  # entryID
    exists: [min, 1, max, infty]
    definition(NX_CHAR):
      \@version(NX_CHAR):
        exists: optional
      enumeration: [NXapm]
    profiling(NXcs_profiling):
      exists: optional
      doc: |
        The configuration of the I/O writer software (e.g. `pynxtools <https://github.com/FAIRmat-NFDI/pynxtools>`_ or its plugins)
        which was used to generate this NeXus file instance.
      # command_line_call(NX_CHAR):
      programID(NXprogram):  # program1, program2, ...
        exists: [min, 0, max, infty]
        doc: |
          A collection of all programs and libraries which are considered relevant
          to understand with which software tools this NeXus file instance was
          generated. Ideally, to enable a binary recreation from the input data.
          
          Examples include the name and version of the libraries used to write the
          instance. Ideally, the software which writes these NXprogram instances
          also includes the version of the set of NeXus classes i.e. the specific
          set of base classes, application definitions, and  contributed definitions
          with which the here described concepts can be resolved.
          
          For the `pynxtools library <https://github.com/FAIRmat-NFDI/pynxtools>`_
          which is used by the `NOMAD <https://nomad-lab.eu/nomad-lab>`_
          research data management system, it makes sense to store e.g. the GitHub
          repository commit and respective submodule references used.
        program(NX_CHAR):
          \@version(NX_CHAR):
          # \@url:
    experiment_identifier(NXidentifier):
      exists: recommended
      service(NX_CHAR):
      identifier(NX_CHAR):
      is_persistent(NX_BOOLEAN):
    run_number(NX_CHAR):
      exists: recommended
      # cannot be made required as for simulations you do not have a run number!
      doc: |
        The identifier whereby the experiment is referred to in the control software.
        This is neither the specimen_name nor the experiment_identifier. For
        Local Electrode Atom Probe (LEAP) instruments, it is recommended to use the
        run_number from the proprietary software IVAS/APSuite of AMETEK/Cameca.
        For other instruments, such as the one from Stuttgart or Oxcart from Erlangen,
        or the instruments at GPM in Rouen, use the identifier which matches
        best conceptually to the LEAP run number.
        The field does not have to be required if the information is recoverable
        in the dataset which for LEAP instruments is the case (provided these
        RHIT or HITS files respectively are stored alongside a data artifact). 
        With NXapm the RHIT or HITS can be stored as via the NXserialized group
        in the hit_finding algorithm section.
        
        As a destructive microscopy technique, a run can be performed only once.
        It is possible, however, to interrupt a run and restart data acquisition
        while still using the same specimen. In this case, each evaporation run
        needs to be distinguished with different run numbers.
        We follow this habit of most atom probe groups. Such interrupted runs
        should be stored as individual :ref:`NXentry` instances in one NeXus file.
    experiment_alias(NX_CHAR):
      doc: |
        Either an identifier or an alias that is human-friendly so that scientists find that experiment again.
        For experiments usually this is the run_number but for simulation typically no run_numbers are issued.
    experiment_description(NX_CHAR):
      exists: optional
      doc: |
        Free-text description about the experiment.
        
        Users are strongly advised to parameterize the description of their experiment
        by using respective groups and fields and base classes instead of writing prose
        into this field.
        
        The reason is that such free-text field is difficult to machine-interpret.
        The motivation behind keeping this field for now is to learn in how far the
        current base classes need extension based on user feedback.
    # optional quantities do not need to be mentioned in an appdef because they can always be added
    # if NXapm inherits from NXapm_base having this optional field does not need to be
    # mentioned because optional nodes can always be added to a NeXus file instance without
    # making it thereby non-compliant to the application definition
    # the only difference is that if the consuming application wishes to demand to find that field
    # it has to be specified in the appdef for the appdef to be a useful document of the contract
    # which pieces of information a software expects to find and which not
    # if you think about you being the consuming human (agent) also you would like to know
    # if there is a run_number for the atom probe measurement from your colleague i.e. you
    # effectively ask your colleague for that information while working off your imagined list of requirements
    # the appdef definition here is nothing else then the documentation of this for a software
    start_time(NX_DATE_TIME):
      doc: |
        ISO 8601 time code with local time zone offset to UTC information
        included when the atom probe session started. If the exact duration of
        the measurement is not relevant start_time only should be used.
        
        Often though it is useful to specify both start_time and end_time to
        capture more detailed bookkeeping of the experiment. The user should
        be aware that even with having both dates specified, it may not be
        possible to infer how long the experiment took or for how long data
        were collected.
        
        More detailed timing data over the course of the experiment have to be
        collected to compute this event chain during the experiment. For this
        purpose the :ref:`NXevent_data_apm` instance should be used.
    end_time(NX_DATE_TIME):
      exists: recommended
      doc: |
        ISO 8601 time code with local time zone offset to UTC included
        when the atom probe session ended.
    (NXcite):
      exists: [min, 0, max, infty]
      doi(NX_CHAR):
    serializedID(NXserialized):
      exists: [min, 0, max, infty]
      type(NX_CHAR):
      path(NX_CHAR):
      checksum(NX_CHAR):
      algorithm(NX_CHAR):
    operation_mode(NX_CHAR):
      doc: |
        What type of atom probe experiment is performed? This field is meant to
        inform research data management systems to allow filtering:
        
        * apt are experiments where the analysis_chamber has no imaging gas.
          experiment with LEAP instruments are typically performed such.
        * fim are experiments where the analysis_chamber has an imaging gas,
          which should be specified with the atmosphere in the analysis_chamber group.
        * apt_fim should be used for combinations of the two imaging modes.
          few experiments of this  type have been performed as this can be detrimental
          to LEAP systems (see `S. Katnagallu et al. <https://doi.org/10.1017/S1431927621012381>`_).
        * other should be used in combination with the user specifying details
          in the experiment_documentation field.
        
        If NXapm is used for storing details about a simulation use other for now.
      enumeration: [apt, fim, apt_fim, other]
    (NXuser):
      exists: recommended
      name(NX_CHAR):
        exists: recommended
      identifier(NXidentifier):
        exists: recommended
        service(NX_CHAR):
        identifier(NX_CHAR):
        is_persistent(NX_BOOLEAN):
    sample(NXsample):
      exists: recommended
      doc: |
        Description of the sample from which the specimen was prepared or
        site-specifically cut out using e.g. a focused-ion beam instrument.
        
        The sample group is currently a place for storing suggestions from
        atom probers about knowledge they have gained about the sample.
        There are cases where the specimen is machined further or exposed to
        external stimuli during the experiment. In this case, these details should
        not be stored under sample but suggestions should be made
        how this application definition can be improved.
        
        In the future also details like how the grain_diameter was characterized,
        how the sample was prepared, how the material was heat-treated etc.,
        should be stored. For this specific application definitions/schemas can be
        used which are then arranged and documented with a description of the
        workflow so that actionable graphs become instantiatable.
      method(NX_CHAR):
        doc: |
          A qualifier whether the sample is a real one
          or a virtual one (in a computer simulation).
        enumeration: [experiment, simulation]
      alias(NX_CHAR):
        doc: |
          Given name/alias for the sample.
      identifier(NXidentifier):
        exists: recommended
        service(NX_CHAR):
        identifier(NX_CHAR):
        is_persistent(NX_BOOLEAN):
      grain_diameter(NX_FLOAT):
        exists: optional
        doc: |
          Qualitative information about the grain size, here specifically
          described as the equivalent spherical diameter of an assumed
          average grain size for the crystal ensemble.
          Users of this information should be aware that although the grain
          diameter or radius is often referred to as grain size.
          
          In atom probe it is possible that the specimen may contain a few
          crystals only. In this case the grain_diameter is not a reliable
          descriptor. Reporting a grain size may be useful though as it allows
          judging if specific features are expected to be found in the
          detector hit map.
        unit: NX_LENGTH
      grain_diameter_error(NX_FLOAT):
        exists: optional
        doc: |
          Magnitude of the standard deviation of the grain_diameter.
        unit: NX_LENGTH
      heat_treatment_temperature(NX_FLOAT):
        exists: optional
        doc: |
          The temperature of the last heat treatment step before quenching.
          Knowledge about this value can give an idea how the sample
          was heat treated. However, if a documentation of the annealing
          treatment as a function of time is available one should better
          rely on this information and have it stored alongside the NeXus file.
        # schema for heat treatment
        unit: NX_TEMPERATURE
      heat_treatment_temperature_error(NX_FLOAT):
        exists: optional
        doc: |
          Magnitude of the standard deviation of the heat_treatment_temperature.
        unit: NX_TEMPERATURE
      heat_treatment_quenching_rate(NX_FLOAT):
        exists: optional
        doc: |
          Rate of the last quenching step. Knowledge about this value can give
          an idea how the sample was heat treated. However, there are many
          situations where one can imagine that the scalar value for just the
          quenching rate is insufficient.
          
          An example is when the sample was left in the furnace after the
          furnace was switched off. In this case the sample cools down with
          a specific rate of how this furnace cools down in the lab.
          Processes which in practice are often not documented.
          
          This can be problematic though because when the furnace door was left open
          or the ambient temperature in the lab changed, i.e. for a series of
          experiments where one is conducted on a hot summer day and the next
          during winter this can have an effect on the evolution of the microstructure.
          There are many cases where this has been reported to be an QA issue in industry,
          e.g. think about aging aluminium samples left on the factory
          parking lot on a hot summer day.
        unit: NX_ANY  # K/s
      heat_treatment_quenching_rate_error(NX_FLOAT):
        exists: optional
        doc: |
          Magnitude of the standard deviation of the heat_treatment_quenching_rate.
        unit: NX_ANY
      description(NX_CHAR):
        exists: optional
      chemical_composition(NXchemical_composition):
        exists: recommended
        doc: |
          The chemical composition of the sample. Typically, it is assumed that
          this more macroscopic composition is representative for the material
          so that the composition of the typically substantially less voluminous
          specimen probes from the more voluminous sample.
        normalization(NX_CHAR):
          doc: |
            Reporting compositions as atom and weight percent yields both
            dimensionless quantities but their conceptual interpretation differs.
            A normalization based on atom_percent counts relative to the
            total number of atoms which are of a particular type.
            By contrast, weight_percent normalization factorizes in the
            respective mass of the elements. Python libraries like pint are
            challenged by these differences as at.-% and wt.-% are both
            fractional quantities.
          enumeration: [atom_percent, weight_percent]
        ionID(NXion):
          exists: [min, 1, max, 118]
          chemical_symbol(NX_CHAR):
            doc: |
              Human-readable name of the element (e.g. Fe).
              Name has to be a symbol of an element from the periodic table.
              All symbols in the set of NXion instances inside the group
              chemical_composition need to be disjoint.
          composition(NX_FLOAT):
            doc: |
              Composition value for the element/ion referred to under name.
              The value is normalized based on normalization, i.e. composition
              is either an atom or weight percent quantity.
            unit: NX_DIMENSIONLESS
          composition_error(NX_FLOAT):
            exists: optional
            doc: |
              Magnitude of the standard deviation of the composition (value).
            unit: NX_DIMENSIONLESS 
    specimen(NXsample):
      method(NX_CHAR):
        doc: |
          A qualifier whether the specimen is a real one or a virtual one.
        enumeration: [experiment, simulation]
      alias(NX_CHAR):
        exists: recommended
        doc: |
          Given name an alias. Better use identifier and parent_identifier instead.
          A single NXentry should be used only for the characterization of a single specimen.
      identifier(NXidentifier):
        exists: recommended
        service(NX_CHAR):
        identifier(NX_CHAR):
        is_persistent(NX_BOOLEAN):
      parent_identifier(NXidentifier):
        exists: recommended
        doc: |
          Identifier of the sample from which the specimen was cut or the string
          n/a. The purpose of this field is to support functionalities for
          tracking sample provenance via a research data management system.
        service(NX_CHAR):
        identifier(NX_CHAR):
        is_persistent(NX_BOOLEAN):
      preparation_date(NX_DATE_TIME):
        exists: recommended
        doc: |
          ISO 8601 time code with local time zone offset to UTC information
          when the specimen was prepared.
          
          Ideally, report the end of the preparation, i.e. the last known time
          the measured specimen surface was actively prepared. Ideally, this
          matches the last timestamp that is mentioned in the digital resource
          pointed to by parent_identifier.
          
          Knowing when the specimen was exposed to e.g. specific atmosphere is
          especially required for environmentally sensitive material such as
          hydrogen charged specimens or experiments including tracers with a
          short half time. Additional time stamps prior to preparation_date
          should better be placed in resources which describe but which do not
          pollute the description here with prose. Resolving these connected
          pieces of information is considered within the responsibility of the
          research data management system.
      atom_types(NX_CHAR):
        doc: |
          List of comma-separated elements from the periodic table that are
          contained in the specimen. If the specimen substance has multiple
          components, all elements from each component must be included in
          `atom_types`.
          
          The purpose of the field is to offer research data management systems an
          opportunity to parse the relevant elements without having to interpret
          these from the resources pointed to by parent_identifier or walk through
          eventually deeply nested groups in data instances.
      description(NX_CHAR):
        exists: optional
        doc: |
          Discouraged free-text field.
      is_polycrystalline(NX_BOOLEAN):
        exists: recommended
        doc: |
          Report if the specimen is polycrystalline, in which case it
          contains a grain or phase boundary, or if the specimen is a
          single crystal.
      is_amorphous(NX_BOOLEAN):
        exists: recommended
        doc: |
          Report if the specimen is amorphous.
      initial_radius(NX_FLOAT):
        exists: recommended
        doc: |
          Ideally measured otherwise best elaborated guess of the initial radius of the specimen.
        unit: NX_LENGTH
      shank_angle(NX_FLOAT):
        exists: recommended
        doc: |
          Ideally measured otherwise best elaborated guess of the (initial) shank angle.
          This is a measure of the specimen taper. Define it in such a way that the base of the specimen
          is modelled as a conical frustrum so that the shank angle is the (shortest) angle between
          the specimen space z-axis and a vector on the lateral surface of the cone.
        unit: NX_ANGLE
      # describing the geometry of the specimen
    coordinate_system_set(NXcoordinate_system_set):
      doc: |
        Set to hold different coordinate systems conventions.
        Inspect the description of the :ref:`NXcoordinate_system_set`
        and :ref:`NXcoordinate_system` base classes how to define
        coordinate systems in NeXus. Specific details for application
        in atom probe microscopy follow.
        
        In this research field scientists usually distinguish several
        Euclidean coordinate systems (CS):
        
        * World space;
          a CS specifying a local coordinate system of the planet earth which
          identifies into which direction gravity is pointing such that
          the laboratory space CS can be rotated into this world CS.
        * The laboratory space;
          a CS specifying the room where the instrument is located in or
          a physical landmark on the instrument, e.g. the direction of the
          transfer rod where positive is the direction how the rod
          has to be pushed during loading a specimen into the instrument.
          In summary, this CS is defined by the chassis of the instrument.
        * The specimen space;
          a CS affixed to either the base or the initial apex of the specimen,
          whose z axis points towards the detector.
        * The detector space;
          a CS affixed to the detector plane whose xy plane is usually in the
          detector and whose z axis points towards the specimen.
          This is a distorted space with respect to the reconstructed ion
          positions.
        * The reconstruction space;
          a CS in which the reconstructed ion positions are defined.
          The orientation depends on the analysis software used.
        * Eventually further coordinate systems attached to the
          flight path of individual ions might be defined.
        
        In atom probe microscopy a frequently used choice for the detector
        space (CS) is discussed with the so-called detector space image
        (stack). This is a stack of two-dimensional histograms of detected ions
        within a predefined evaporation identifier interval. Typically, the set of
        ion evaporation sequence IDs is grouped into chunks.
        
        For each chunk a histogram of the ion hit positions on the detector
        is computed. This leaves the possibility for inconsistency between
        the so-called detector space and the e.g. specimen space.
        
        To avoid these ambiguities, instances of :ref:`NXtransformations` should
        be used.
      (NXcoordinate_system):
        exists: [min, 1, max, infty]
        origin(NX_CHAR):
        alias(NX_CHAR):
        type(NX_CHAR):
        handedness(NX_CHAR):
        x_direction(NX_CHAR):
        y_direction(NX_CHAR):
        z_direction(NX_CHAR):

    measurement(NXapm_msr):
      exists: optional
      instrument(NXinstrument):
        instrument_name(NX_CHAR):
          exists: optional
        fabrication(NXfabrication):
          vendor(NX_CHAR):
          model(NX_CHAR):
          identifier(NX_CHAR):
            exists: recommended
        reflectron(NXreflectron):
          status(NX_CHAR):
          fabrication(NXfabrication):
            exists: recommended
            vendor(NX_CHAR):
            model(NX_CHAR):
        # decelerate_electrode(NXlens_em):
        local_electrode(NXlens_em):
          # add flat test status
          name(NX_CHAR):
          fabrication(NXfabrication):
            exists: recommended
            vendor(NX_CHAR):
            model(NX_CHAR):
        ion_detector(NXdetector):
          exists: recommended
          fabrication(NXfabrication):
            exists: recommended  # for LEAP systems they come shipped configured
            vendor(NX_CHAR):
            model(NX_CHAR):
        pulser(NXpulser_apm):
          fabrication(NXfabrication):
            exists: recommended
            vendor(NX_CHAR):
            model(NX_CHAR):
          pulse_mode(NX_CHAR):
          sourceID(NXsource):
            exists: [min, 0, max, 2]  # conditionally required if pulse_mode is not voltage!
            fabrication(NXfabrication):
              exists: recommended
              vendor(NX_CHAR):
              model(NX_CHAR):
            wavelength(NX_FLOAT):
              doc: |
                The wavelength of the radiation emitted by the source.
              unit: NX_WAVELENGTH
            # use NXbeam in the future
        # stage_lab(NXstage_lab):
        analysis_chamber(NXchamber):
          exists: recommended
          flight_path(NX_FLOAT):
            exists: recommended
            doc: |
              The space inside the atom probe along which ions pass nominally
              when they leave the specimen and travel to the detector.
            unit: NX_LENGTH
        # atmosphere(NXcollection):
        # buffer_chamber(NXchamber):
        # load_lock_chamber(NXchamber):
        # getter_pump(NXpump):
        # roughening_pump(NXpump):
        # turbomolecular_pump(NXpump):
        status(NX_CHAR):
      event_data_apm_set(NXevent_data_apm_set):
        exists: optional
        # the case of allowing to not have event_data but only the above-mentioned instrument
        # details can be useful to convey details about an atom probe instrument in general
        event_data_apm(NXevent_data_apm):
          exists: recommended
          # all these cannot be made required because for LEAP only stored in RHIT/HITS
          # but for M-TAP and Oxcart these pieces of information are available.
          # start_time(NX_DATE_TIME):
          # end_time(NX_DATE_TIME):
          # delta_time(NX_NUMBER):
          # pulse_identifier_offset(NX_INT):
          # pulse_identifier(NX_INT):
          instrument(NXinstrument):
            exists: recommended
            control(NXcollection):
              evaporation_control(NX_CHAR):
              target_detection_rate(NX_FLOAT):
            # optional groups can always be added but they will not be annotated eventually properly by pynxtools
            # reflectron(NXreflectron):
            # decelerate_electrode(NXlens_em):
            # local_electrode(NXlens_em):
            # ion_detector(NXdetector):
              # exists: optional
              # signal_amplitude(NX_FLOAT):
            pulser(NXpulser_apm):
              pulse_frequency(NX_FLOAT):
                # unit: NX_FREQUENCY
                # dim: (p,)
                \@logged_against(NX_CHAR):
              pulse_fraction(NX_FLOAT):
                # unit: NX_DIMENSIONLESS
                # dim: (p,)
                \@logged_against(NX_CHAR):
              pulse_voltage(NX_FLOAT):  # pulsed voltage
                exists: recommended  # not required for voltage pulsing
                # unit: NX_VOLTAGE
                # dim: (p,)
                \@logged_against(NX_CHAR):
              # pulse_number(NX_UINT):
              standing_voltage(NX_FLOAT):
                # unit: NX_VOLTAGE
                # dim: (p,)
                \@logged_against(NX_CHAR):
              (NXsource):
                exists: [min, 0, max, 2]  # not required for voltage pulsing
                pulse_energy(NX_FLOAT):
                  # unit: NX_ENERGY
                  # dim: (p,)
                  \@logged_against(NX_CHAR):
              # laser geometry at the moment has no example nor any feedback from the community
              # but NXpulser_apm base class shows how this could be done, plus examples for NXmpes
            stage_lab(NXstage_lab):
              # setpoint_temperature(NX_FLOAT):
              base_temperature(NX_FLOAT):
            analysis_chamber(NXchamber):
              chamber_pressure(NX_FLOAT):
            # buffer_chamber(NXchamber):
            # load_lock_chamber(NXchamber):
            # getter_pump(NXpump):
            # roughening_pump(NXpump):
            # turbomolecular_pump(NXpump):

    simulation(NXapm_sim):
      exists: optional

    atom_probe(NXroi):
      exists: recommended  # [min, 0, max, infty]
      doc: |
        A region-of-interest analyzed either during or after the session for which
        specific processed data of the measured or simulated data are available.
      # add a default plot V = f(time/evaporation_id), essentially for each quantity
      # NEW ISSUE: check also here the PYCCAPT pipeline from P. Felfer's group
      # all other details are instances of NXprocess as steps along the pipeline

      # NEW ISSUE: hit_quality table 
      # NEW ISSUE: pyccapt
      # NEW ISSUE: add section for propagation_delay(NXprocess) ?
      # NEW ISSUE: make recon an own subentry NXapm_reconstruction
      # NEW ISSUE: different algorithms used one could create a class for each reconstruction method
      # NEW ISSUE: make this rather an own subentry NXapm_ranging

      initial_specimen(NXimage_set):
        exists: recommended
        doc: |
          SEM or TEM image of the initial specimen i.e.
          ideally taken prior to the data acquisition.
        image_2d(NXdata):
          \@signal(NX_CHAR):
          \@axes(NX_CHAR):
          \@AXISNAME_indices(NX_CHAR):
          real(NX_NUMBER):
          axis_j(NX_NUMBER):
            dim: (n_j,)
            \@long_name(NX_CHAR):
          axis_i(NX_NUMBER):
            dim: (n_i,)
            \@long_name(NX_CHAR):
       # one could use a stack_3d(NXdata) to record
       # a time series of the specimen shape evolution

      raw_data(NXprocess):
        exists: recommended
        sequence_index(NX_POSINT):
          exists: recommended
        programID(NXprogram):
          exists: [min, 0, max, infty]
          program(NX_CHAR):
            \@version(NX_CHAR):
        # point at least to the proprietary artifact
        serialized(NXserialized):
          exists: recommended
          type(NX_CHAR):
          path(NX_CHAR):
          checksum(NX_CHAR):
          algorithm(NX_CHAR):

      hit_finding(NXapm_hit_finding):
        exists: recommended
        # we careful how we go about doing this here, we recommended to make some details of the hit_finding
        # algorithm open namely the input and the output what the black box then does by AMETEK/Cameca
        # does not have to be exposed (although this clearly is against FAIR principles but the scientific community
        # is does not have the authority to decide which portions of proprietary code have to be public
        # we can only make recommendations
        sequence_index(NX_POSINT):
          exists: recommended
        programID(NXprogram):
          exists: [min, 0, max, infty]
          program(NX_CHAR):
            \@version(NX_CHAR):
        # config of the hit_finding algorithm
        serialized(NXserialized):
          exists: recommended
          type(NX_CHAR):
          path(NX_CHAR):
          checksum(NX_CHAR):
          algorithm(NX_CHAR):
        number_of_dld_wires(NX_UINT):
          exists: recommended
        arrival_time_pairs(NX_NUMBER):
          exists: optional
        # results of the hit_finding algorithm
        hit_quality_types(NX_CHAR):
          exists: optional
        hit_quality_identifier(NX_UINT):
          exists: optional
        hit_positions(NX_NUMBER):
          exists: recommended
          dim: (i, 2)
        hit_quality(NX_UINT):
          exists: optional
          dim: (i,)
        hit_multiplicity(NX_UINT):
          exists: recommended
          dim: (i,)
        # statistics(NXprocess):
        #   multiples(NX_FLOAT):
        #     doc: |
        #       Fraction of multiple hits.
        #     unit: NX_DIMENSIONLESS
        # the following two quantities are relicts from ePOS files used to give some
        # insight into the results of the hit_finding algorithm of IVAS/APSuite but typically
        # used only in the context to learn about the multiplicity of an ion.
        # pulses_since_last_ion(NX_UINT):
        #   exists: optional
        #   dim: (i,)
        # pulse_identifier(NX_INT):  # this is the pulse on which they came
        #   exists: optional
        #   dim: (i,)
        # i number of hits after hits finding but prior calibrations

      hit_spatial_filtering(NXprocess):
        exists: recommended
        sequence_index(NX_POSINT):
          exists: recommended
        programID(NXprogram):
          exists: [min, 1, max, infty]
          program(NX_CHAR):
            \@version(NX_CHAR):
        serialized(NXserialized):
          exists: optional
          type(NX_CHAR):
          path(NX_CHAR):
          checksum(NX_CHAR):
          algorithm(NX_CHAR):
        evaporation_identifier_offset(NX_INT):
          doc: |
            Integer used to name the first pulse to know if there is an
            offset of the evaporation_identifier to zero.
            
            Identifiers can be defined either implicitly or explicitly.
            For implicit indexing identifiers are defined on the interval
            :math:`[identifier\_offset, identifier\_offset + c - 1]`.
            
            Therefore, implicit identifier are completely defined by the value of
            identifier_offset and cardinality. For example if identifier run from
            -2 to 3 the value for identifier_offset is -2.
            
            For explicit indexing the field identifier has to be used.
            Fortran-/Matlab- and C-/Python-style indexing have specific implicit
            identifier conventions where identifier_offset is 1 and 0 respectively.
          unit: NX_UNITLESS
        evaporation_identifier(NX_INT):
          doc: |
            (Molecular) ion identifier which resolves the sequence in which
            the ions were evaporated but taking into account that a hit_finding
            and spatial_filtering was applied.
          unit: NX_UNITLESS
          dim: (n,)
        hit_filter(NXcs_filter_boolean_mask):
          exists: recommended
          # use NXcs_filter needs conditionally an instance of concept ../../hit_finding
          number_of_objects(NX_UINT):
          bitdepth(NX_UINT):
          mask(NX_UINT):
          identifier(NX_INT):

      # at this point the original set of events p has been filtered down to n
      voltage_and_bowl(NXapm_volt_and_bowl):
        exists: recommended
        sequence_index(NX_POSINT):
          exists: recommended
        programID(NXprogram):
          exists: [min, 1, max, infty]
          program(NX_CHAR):
            \@version(NX_CHAR):
        serialized(NXserialized):
          exists: optional
          type(NX_CHAR):
          path(NX_CHAR):
          checksum(NX_CHAR):
          algorithm(NX_CHAR):
        # config/input to the algorithm
        # NEW ISSUE: realistic is that currently scientists can pull always a calibrated time-of-flight
        # but not necessarily unprocessed timing data from the detector (unless individuals built the instrument).
        # Relevant for ranging are the calibrated data, thats why only these
        # (as an intermediate/compromise solution) are required in this version of the application definition
        raw_tof(NX_FLOAT):
          exists: recommended
          dim: (n,)
        # result
        calibrated_tof(NX_FLOAT):
          dim: (n,)

      mass_to_charge_conversion(NXprocess):
        exists: recommended
        sequence_index(NX_POSINT):
          exists: recommended
        programID(NXprogram):
          exists: [min, 1, max, infty]
          program(NX_CHAR):
            \@version(NX_CHAR):
        serialized(NXserialized):
          exists: recommended
          type(NX_CHAR):
          path(NX_CHAR):
          checksum(NX_CHAR):
          algorithm(NX_CHAR):
        # config/input
        # results
        mass_to_charge(NX_FLOAT):
          dim: (n,)

      reconstruction(NXapm_reconstruction):
        exists: recommended
        sequence_index(NX_POSINT):
          exists: recommended
        programID(NXprogram):
          exists: [min, 1, max, infty]
          program(NX_CHAR):
            \@version(NX_CHAR):
        config(NXserialized):
          exists: recommended
          doc: |
            For LEAP and IVAS/APSuite-based analyses root file which stores
            the settings whereby an RHIT/HITS file can be used to regenerate the
            reconstruction that is here referred to.
            
            The respective RHIT/HITS file should ideally be specified in the serialized
            group of the hit_finding section of this application definition.
          type(NX_CHAR):
          path(NX_CHAR):
          checksum(NX_CHAR):
          algorithm(NX_CHAR):
        results(NXserialized):
          exists: recommended
          doc: |
            For LEAP and IVAS/APSuite-based analyses the resulting typically
            file with the reconstructed positions and (calibrated) mass-to-charge
            state ratio values.
            
            For other data collection/analysis software the data artifact which comes
            closest conceptually to AMETEK/Cameca's typical file formats.
            
            These are typically exported as a POS, ePOS, APT, ATO, ENV, or HDF5 file,
            which should be stored alongside this record in the research data
            management system.
          type(NX_CHAR):
          path(NX_CHAR):
          checksum(NX_CHAR):
          algorithm(NX_CHAR):
        # config/input
        parameter(NX_CHAR):
        protocol_name(NX_CHAR):
          exists: recommended
        crystallographic_calibration(NX_CHAR):
          exists: recommended
        field_of_view(NX_FLOAT):
          exists: recommended
        reconstructed_positions(NX_FLOAT):
          dim: (n, 3)
        naive_discretization(NXprocess):
          programID(NXprogram):
            exists: [min, 1, max, infty]
            program(NX_CHAR):
              \@version(NX_CHAR):
          # config/input
          # results
          (NXdata):
            \@signal(NX_CHAR):
            \@axes(NX_CHAR):
            \@AXISNAME_indices(NX_CHAR):
            #  dim: (3,)
            # \@long_name:
            title(NX_CHAR):
            intensity(NX_NUMBER):
              dim: (n_z, n_y, n_x)
            axis_z(NX_FLOAT):
              dim: (n_z,)
              \@long_name(NX_CHAR):
            axis_y(NX_FLOAT):
              dim: (n_y,)
              \@long_name(NX_CHAR):
            axis_x(NX_FLOAT):
              dim: (n_x,)
              \@long_name(NX_CHAR):

      ranging(NXapm_ranging):
        exists: recommended
        sequence_index(NX_POSINT):
          exists: recommended
        programID(NXprogram):
          exists: [min, 1, max, infty]
          program(NX_CHAR):
            \@version(NX_CHAR):
        definitions(NXserialized):
          exists: recommended
          doc: |
            The respective ranging definitions file RNG/RRNG/ENV/HDF5.
          type(NX_CHAR):
          path(NX_CHAR):
          checksum(NX_CHAR):
          algorithm(NX_CHAR):
        # number_of_ion_types(NX_UINT):
        maximum_number_of_atoms_per_molecular_ion(NX_UINT):

        mass_to_charge_distribution(NXprocess):
          exists: recommended
          sequence_index(NX_POSINT):
            exists: recommended
          programID(NXprogram):
            exists: [min, 1, max, infty]
            program(NX_CHAR):
              \@version(NX_CHAR):
          min_incr_max(NX_FLOAT):
            # dim: (3,)  # u
          mass_spectrum(NXdata):
            \@signal(NX_CHAR):
            \@axes(NX_CHAR):
            \@AXISNAME_indices(NX_CHAR):
            # \@long_name(NX_CHAR):
            title(NX_CHAR):
            intensity(NX_NUMBER):
              dim: (n_bins,)
              \@long_name(NX_CHAR):
            axis_mass_to_charge(NX_FLOAT):
              dim: (n_bins,)
              \@long_name(NX_CHAR):

        background_quantification(NXprocess):
          exists: recommended
          sequence_index(NX_POSINT):
            exists: recommended
          programID(NXprogram):
            exists: [min, 1, max, infty]
            program(NX_CHAR):
              \@version(NX_CHAR):
          background(NX_FLOAT):
            exists: recommended
            doc: |
              (Out-of-sync) background levels in ppm/ns
              reported by e.g. IVAS/APSuite for LEAP systems.
            unit: NX_ANY  # ppm/ns
          mrp_value(NX_FLOAT):
            exists: recommended
            doc: |
              MRP, mass-resolving power, `D. Larson et al. <https://doi.org/10.1007/978-1-4614-8721-0>`_ (p282, Eqs. D.7 and D.8).
            unit: NX_DIMENSIONLESS
          mrp_mass_to_charge(NX_FLOAT):
            exists: recommended
            doc: |
              MRP, at which mrp_value was specified.
            unit: NX_ANY  # u
          # config/input
          # results
          # NEW ISSUE: add parameters of the background model
          # in an e.g. work of A. London et al.

        peak_search(NXprocess):
          exists: recommended
          sequence_index(NX_POSINT):
            exists: recommended
          programID(NXprogram):
            exists: [min, 1, max, infty]
            program(NX_CHAR):
              \@version(NX_CHAR):
          peakID(NXpeak):
            exists: [min, 0, max, infty]
            label(NX_CHAR):
              exists: recommended
            description(NX_CHAR):
            category(NX_CHAR):
              exists: recommended
              doc: |
                Category for the peak offering a qualitative statement of the location of the peak
                in light of limited mass-resolving power that is relevant for
                composition quantification. See `D. Larson et al. (p172) <https://doi.org/10.1007/978-1-4614-8721-0>`_ 
                for examples of each category:
                
                * 0, well-separated, :math:`^{10}B^{+}`, :math:`^{28}Si^{2+}`
                * 1, close, but can be sufficiently separated for quantification in a LEAP system, :math:`^{94}Mo^{3+}`, :math:`^{63}Cu^{2+}`
                * 2, closely overlapping, demands better than LEAP4000X MRP can provide :math:`^{14}N^{+}`, :math:`^{28}Si^{2+}` at different charge states
                * 3, overlapped exactly due to multi-charge molecular species, :math:`^{16}{O_{2}}^{2+}`, :math:`^{16}O^{+}`
                * 4, overlapped, same charge state, cannot as of 2013 be discriminated with a LEAP4000X, :math:`^{14}{N_{2}}^{+}`, :math:`^{28}Si^{+}`
                * 5, overlapped, same charge state, any expectation of resolvability, :math:`^{54}Cr^{2+}`, :math:`^{54}Fe^{2+}`
                
              enumeration: [0, 1, 2, 3, 4, 5]
            position(NX_NUMBER):

        # peak deconvolution(NXprocess):

        peak_identification(NXprocess):  # aka specify ranging definitions i.e. mqmin, mqmax intervals (ranges) and (molecular) ion candidates
          exists: recommended
          sequence_index(NX_POSINT):
            exists: recommended
          programID(NXprogram):
            exists: [min, 1, max, infty]
            program(NX_CHAR):
              \@version(NX_CHAR):
          ionID(NXion):
            exists: [min, 1, max, 256]
            nuclide_hash(NX_UINT):
            charge_state(NX_INT):
            charge_state_analysis(NXapm_charge_state_analysis):
              exists: optional
              # config
              nuclides(NX_UINT):
              mass_to_charge_range(NX_FLOAT):
              min_half_life(NX_FLOAT):
              min_abundance(NX_FLOAT):
              min_abundance_product(NX_FLOAT):
              sacrifice_isotopic_uniqueness(NX_BOOLEAN):
              # results
              charge_state(NX_INT):
              nuclide_hash(NX_UINT):
              mass(NX_FLOAT):
              natural_abundance_product(NX_FLOAT):
              shortest_half_life(NX_FLOAT):
            mass_to_charge_range(NX_FLOAT):
            nuclide_list(NX_UINT):
              exists: recommended
            name(NX_CHAR):
              exists: recommended
