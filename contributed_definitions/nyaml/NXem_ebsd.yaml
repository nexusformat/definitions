category: base
doc:
- |
  Base class method-specific for Electron Backscatter Diffraction (EBSD).
- |
  The general procedure of an EBSD experiment is as follows.
  Users load the specimen, collect first a coarse image of the surface.
  Next, they set an approximate value for the calibrated working distance and
  tilt the stage to set the desired diffraction conditions.
- |
  Users then typically configure the microscope for collecting higher quality data
  and push in the EBSD detector. Subsequently, they fine tune the illumination
  and aberration corrector settings and select one or multiple ROIs for
  the microscope to machine off automatically. They configure on-the-fly
  indexing parameter and start the measurement queue.
- |
  Nowadays, this is in most cases an automated process. The pattern
  collection runs during the allocated microscope session until the
  queue finishes or gets interrupted by errors or the next user terminates
  sessions which run over time.
- |
  Kikuchi pattern surplus eventually multi-modal detector signals are
  collected and usually indexed on-the-fly. Patterns may be stored or not
  so one should not assume that raw data are always stored.
- |
  Results are stored in files, which afterwards are typically copied
  automatically or manual for archival purposes to certain storage
  locations or further consumption. The result of such an EBSD
  measurement/experiment is a set of usually proprietary or open files
  from technology partners.
- |
  This :ref:`NXem_ebsd` base class is a proposal how to represent method-specific
  data, metadata, and connections between these for the research field of
  electron microscopy.
- |
  More specifically, exemplified here for electron backscatter diffraction (EBSD)
  we show how NeXus can be used to solve two key documentation issues so far
  missing in the field of EBSD.
- |
  Firstly, an instance of NXem_ebsd (such as a NeXus/HDF5 file which is formatted
  according to NXem_ebsd) stores the connection between the microscope session and
  the key datasets which are considered typically results of the various processing
  steps involved when working with EBSD data.
- |
  Different groups in NXem_ebsd make connections to data artifacts which were collected
  when working with electron microscopes via the NXem application definition.
  Using a file which stores information according to the NXem application definition
  has the benefit that it connects the sample, references to the sample processing,
  the user operating the microscope, details about the microscope session,
  and details about the acquisition and eventual indexing of Kikuchi pattern,
  associated overview images, like secondary electron or backscattered electron
  images of the region-of-interest probed and many more pieces of information.
- |
  Secondly, NXem_ebsd connects and stores the conventions and reference frames
  which were used and which are the key to a correct mathematical interpretation
  of every EBSD result. Otherwise, results would be ripped out of their context,
  as it is the current situation with many traditional studies where EBSD data
  were indexed on-the-fly and shared with the community only via sharing
  the strongly processed results file in some technology-partner-specific file
  format but without communicating all conventions or relying on the assumptions
  that colleagues likely know these conventions even though multiple definitions
  are possible.
- |
  NXem_ebsd covers experiments with one-, two-dimensional, and so-called three-
  dimensional EBSD datasets. The third dimension is either time (in the case of
  quasi in-situ experiments) or space (in the case of serial-sectioning) methods
  where a combination of mechanical or ion milling is used repetitively to measure
  the same region-of-interest at different depth increments. Material removal
  can be achieved with electron or ion polishing, using manual
  steps or using automated equipment like a robot system.
- |
  Three-dimensional experiments require to follow a sequence of specimen, surface
  preparation, and data collection steps. By nature these methods are destructive
  in that they either require the removal of the previously measured material region
  or that the sample surface can degrade due to e.g. contamination or other
  electron-matter interaction.
- |
  For three-dimensional EBSD, multiple two-dimensional EBSD orientation mappings are
  combined into one reconstructed stack. That is serial-sectioning is mainly a
  computational workflow. Users collect data for each serial sectioning step
  via an experiment. This assures that data for associated microscope sessions
  and steps of data processing stay connected and contextualized.
- |
  Eventual tomography methods also use such a workflow because first diffraction
  images are collected (e.g. with X-ray) and then these imagres are indexed and
  computed into a 3D orientation mapping. The here proposed NXem_ebsd application
  definition contains conceptual ideas how this splitting between measurement and
  post-processing can be granularized also for such X-ray-based techniques, whether
  it be 3DXRD or HEDM.
- |
  xref:
    spec: EMglossary
    term: Electron Backscatter Diffraction
    url: https://purls.helmholtz-metadaten.de/emg/EMG_00000019
symbols:
  n_op: |
    Number of arguments per orientation for given parameterization.
  n_sc: |
    Number of scan points.
  n_z: |
    Number of pixel along the slowest changing dimension for a rediscretized,
    i.e. standardized default plot orientation mapping.
  n_y: |
    Number of pixel along slow changing dimension for a rediscretized i.e.
    standardized default plot orientation mapping.
  n_x: |
    Number of pixel along fast changing dimension for a rediscretized i.e.
    standardized default plot orientation mapping.
  n_solutions: |
    Number of phase solutions
type: group
NXem_ebsd(NXem_method):
  
  # (NXcoordinate_system):
  gnomonic_reference_frame(NXcoordinate_system):
    doc: |
      Details about the gnomonic (projection) reference frame.
      
      It is assumed that the configuration is inspected by looking towards the sample surface.
      If a detector is involved, it is assumed that the configuration is inspected from a position
      that is located behind this detector.
      
      If any of these assumptions is not met, the user is required to explicitly state this.
      
      Reference DOI: 10.1016/j.matchar.2016.04.008 suggests to label the
      base vectors of this coordinate system as Xg, Yg, Zg.
    origin(NX_CHAR):
      doc: |
        Origin of the gnomonic_projection_reference_frame.
        
        Reference DOI: 10.1016/j.matchar.2016.04.008 suggests to
        assume that this is coordinate Xg = 0, Yg = 0, Zg = 0.
      enumeration: [undefined, in_the_pattern_centre]
    x_direction(NX_CHAR):
      doc: |
        Direction of the positively pointing x-axis base vector of the
        gnomonic_reference_frame.
      enumeration: [undefined, north, east, south, west, in, out]
    y_direction(NX_CHAR):
      doc: |
        Direction of the positively pointing y-axis base vector of the
        gnomonic_reference_frame.
      enumeration: [undefined, north, east, south, west, in, out]
    z_direction(NX_CHAR):
      doc: |
        Direction of the positively pointing z-axis base vector of the
        gnomonic_reference_frame.
      enumeration: [undefined, north, east, south, west, in, out]
  pattern_centre(NXprocess):
    doc: |
      Details about the definition of the pattern centre as a special point in the gnomonic_reference_frame.
      
      Keep in mind that the gnomonic space is in virtually all cases embedded in the detector space.
      Specifically, the XgYg plane is defined such that it is laying inside the XdYd plane
      (of the detector reference frame).
      
      When the normalization direction is the same as e.g. the detector x-axis direction one
      effectively normalizes in fractions of the width of the detector.
      
      The issue with terms like width and height is that these degenerate if the detector
      region-of-interest is square-shaped. This is why instead of referring to width and height
      one should report as if one were to measure practically with a ruler and one is specific
      about in which direction positive distances are measured.
      
      For the concepts used to specify the boundary_convention it is assumed that the
      region-of-interest is defined by a rectangle, referring to the direction of outer-unit
      normals to the respective edges of this rectangle.
    x_boundary_convention(NX_CHAR):
      doc: |
        From which border of the EBSP (in the detector reference frame) is the pattern
        centre's x-position (PCx) measured.
      enumeration: [undefined, top, right, bottom, left]
    x_normalization_direction(NX_CHAR):
      doc: |
        In which direction are positive values for the x-axis coordinate value measured
        from the specified boundary.
      enumeration: [undefined, north, east, south, west]
    y_boundary_convention(NX_CHAR):
      doc: |
        From which border of the EBSP (in the detector reference frame) is the pattern
        centre's y-position (PCy) measured.
      enumeration: [undefined, top, right, bottom, left]
    y_normalization_direction(NX_CHAR):
      doc: |
        In which direction are positive values for the y-axis coordinate value measured
        from the specified boundary.
      enumeration: [undefined, north, east, south, west]
  
  # distance_convention:
  # doc: |
  # How is the third of the three pattern centre parameter values,
  # the (distance) parameter DD, normalized. Which convention
  # is followed. We are aware that specifying one of the options here
  # also implicitly comes with conventions for some of the parameter
  # requested in this ELN. For now we would rather like to ask
  # the users though to be specific also to learn how such an ELN
  # will be used in practice.
  # enumeration: [undefined, Bruker, JEOL, FEI, Oxford]
  measurement(NXprocess):
    doc: |
      This group documents relevant details about the conditions and the tools
      used for measuring a stack of Kikuchi diffraction pattern with an
      electron microscope.
      
      The most frequently collected EBSD data are captured for rectangular
      regions-of-interested which are sampled with regular square or
      hexagon-shaped pixels.
    time(NX_NUMBER):
      unit: NX_TIME
      doc: |
        Physical time since the beginning of a timestamp that is required to be
        same for all experiments in the set. The purpose of this marker is
        to identify how all experiments in the set need to be arranged
        sequentially based on the time elapsed.
        The time is relevant to sort e.g. experiments of consecutive quasi
        in-situ experiments where a measurement was e.g. taken after 0 minutes,
        30 minutes, 6 hours, or 24 hours of annealing.
      \@epoch_start(NX_CHAR):
        doc: |
          Timestamp relative to which time was counted to aid
          converting between time and timestamp.
    
    # (NXtransformations):
    # doc: |
    # Transformation which details where the region-of-interest described under
    # indexing is located in absolute coordinates and rotation with respect
    # to which coordinate system.
    # pattern_available(NX_BOOLEAN):
    # doc: |
    # True if pattern were stored and are retrieveable via depends_on or source.
    depends_on(NX_CHAR):
      doc: |
        If available and it is stored in an instance of an application definition this field
        specifies the path to an instance of :ref:`NXdata` where the measured patterns
        are stored.
    source(NXserialized):
      doc: |
        Reference (e.g. path and filename) to an existent data artifact which
        stores either the measured pattern or input (already processed EBSD data).
  simulation(NXprocess):
    doc: |
      This group documents relevant details about the conditions and the tools
      used for simulating a stack of Kikuchi diffraction pattern with some
      physical model.
      
      This group should not be confused with a group named simulation that
      is however an instance of NXem_sim. Instead, the simulation group here
      should be used if (e.g. instead of a measurement) a stack of pattern
      were simulated that one wishes to use for indexing patterns.
      
      In many practical cases where pattern are analyzed on-the-fly and dictionary
      indexing strategies are used, so-called master pattern(s) are used to compare
      measured or simulated pattern with the master pattern. In this case,
      master pattern are the result of a computer simulation and thus should
      be stored using an own properly documented entry within a simulation
      group as an instance of :ref:`NXem_sim`.
    depends_on(NX_CHAR):
      doc: |
        If available and it is stored in an instance of an application definition this field specifies
        the path to an instance of :ref:`NXimage_set` where the simulated patterns are stored.
    source(NXserialized):
      doc: |
        Reference (e.g. path and filename) to an existent digital resource which
        stores either the pattern or input (already processed EBSD data)
        which is now processed further as described by this NXem_ebsd instance.
  calibration(NXprocess):
    doc: |
      The EBSD system, including components like the electron gun, pole-piece,
      stage tilting, EBSD detector, and the gnomonic projection have to be
      calibrated to achieve reliable indexing results.
      
      Specifically, the gnomonic projection has to be calibrated.
      Typically, silicon or quartz crystals are used for this purpose.
      
      Considering a system is well-calibrated, it is much more frequently the
      case in practice that users assume the system is calibrated (and thus usable)
      vs. they perform the calibration of the EBSD system.
      
      In the first case, the user assumes that the principle geometry of the
      hardware components and the settings in the control and EBSD pattern
      acquisition software has been calibrated. Consequently, users pick from
      an existent library of phase candidates, i.e.
      :ref:`NXcrystal_structure` instances. Examples are
      reflector models as stored in CRY files (HKL/Channel 5/Flamenco).
      
      In the second case, users calibrate the system during the session
      using standards (silicon, quartz, or other common specimens).
      There is usually one person in each lab responsible for doing such
      calibrations. Often this person or technician is also in charge of
      configuring the graphical user interface and software with which most
      users control and perform their analyses.
      
      For EBSD this has key implications: Taking TSL OIM/EDAX as an example,
      the conventions how orientations are stored is affected by how the
      reference frames are configured and this setup is made at the level
      of the GUI software.
      
      Unfortunately, these pieces of information are not necessarily stored
      in the results files. In effect, key conventions become disconnected
      from the data so it remains the users' obligation to remember these
      settings or write these down in a lab notebook. Otherwise, these metadata
      get lost. All these issues are a motivation and problem which
      :ref:`NXem_ebsd` solves in that all conventions can be specified explicitly.
    depends_on(NX_CHAR):
      doc: |
        If available and it is stored in an instance of an application definition this field specifies
        the path to an instance of :ref:`NXem_msr` where calibration is stored.
    source(NXserialized):
      doc: |
        Reference to a digital resource where the calibration is stored.
  indexing(NXprocess):
    doc: |
      Indexing is a data processing step performed either after or while
      (on-the-fly) the beam scans the specimen. The resulting method is also
      known as orientation imaging microscopy (OIM).
      
      Different algorithms can be used to index EBSD pattern. Common to them
      is the computational step where simulated reference pattern are compared
      with measured or simulated patterns. These latter patterns are referred
      to via the measurement or simulation groups of this base class.
      
      Quality descriptors are defined based on which an indexing algorithm
      yields a quantitative measure of how similar measured and reference
      pattern are, and thus if no, one, or multiple so-called solutions
      were found.
      
      Assumed or simulated pattern are simulated using kinematic or dynamical
      theory of electron diffraction delivering master pattern.
      
      The Hough transform is essentially a discretized Radon transform (for details see `M. van Ginkel et al. <https://www.semanticscholar.org/paper/A-short-introduction-to-the-Radon-and-Hough-and-how-Ginkel/fb6226f606cad489a15e38ed961c419037ccc858>`_).
      Recently, dictionary-based indexing methods are increasingly becoming used
      partly driven by the interest to use artificial intelligence algorithms.
    source(NXserialized):
      doc: |
        This group enables to establish a logical connection between previous
        processing steps or on-the-fly-performed indexing of the EBSD map.
        Typically these processing steps are performed with commercial software.
        Therefore, in many cases a results file from this indexing is often
        all that is communicated and saved. These are typically files in a format
        specific to the instrument and its configuration.
        
        Typical file formats are CPR/CRC, ANG, OSC, HDF5, H5EBSD, EDAXH5.
    method(NX_CHAR):
      doc: |
        Principal algorithm used for indexing.
      enumeration: [undefined, hough_transform, dictionary, radon_transform, other]
    background_correction(NXprocess):
      doc: |
        Details about the background correction applied to each Kikuchi pattern.
    binning(NXprocess):
      doc: |
        Binning i.e. downsampling of the pattern.
    parameter(NXprocess):
      doc: |
        Specific parameter relevant only for certain algorithms used.
    phaseID(NXcrystal_structure):
      doc: |
        Details for each phase used as a model with which the patterns were
        indexed. Instances of :ref:`NXcrystal_structure` in this group must
        have the group name prefix phase. The identifier in the name is an
        integer. We start counting from 1 because the value 0 is reserved for
        the special phase that is the null-model, i.e. the null phase, notIndexed.
    status(NX_UINT):
      unit: NX_UNITLESS
      doc: |
        Which return value did the indexing algorithm yield for each scan point.
        Practically useful is to use an uint8 mask.
        
        * 0 - Not analyzed
        * 1 - Too high angular deviation
        * 2 - No solution
        * 100 - Success
        * 255 - Unexpected errors
      dimensions:
        rank: 1
        dim: (n_sc,)
    n_phases_per_scan_point(NX_INT):
      unit: NX_UNITLESS
      doc: |
        How many phases i.e. crystal structure models were used to index each
        scan point if any? Let's assume an example to explain how this field
        should be used: In the simplest case users collected one pattern for
        each scan point and have indexed using one phase, i.e. one instance
        of an NXem_ebsd_crystal_structure_model.
        
        In another example users may have skipped some scan points (not indexed)
        them at all) and/or used differing numbers of phases for different scan
        points.
        
        The cumulated of this array decodes how phase_identifier and phase_matching
        arrays have to be interpreted. In the simplest case (one pattern per scan
        point, and all scan points indexed using that same single phase model),
        phase_identifier has as many entries as scan points
        and phase_matching has also as many entries as scan points.
      dimensions:
        rank: 1
        dim: (n_sc,)
    phase_identifier(NX_INT):
      unit: NX_UNITLESS
      doc: |
        The array n_phases_per_scan_point details how the phase_identifier
        and the phase_matching arrays have to be interpreted.
        
        For the example with a single phase phase_identifier has trivial
        values either 0 (no solution) or 1 (solution matching
        sufficiently significant with the model for phase 1).
        
        When there are multiple phases, it is possible (although not frequently
        needed) that a pattern matches eventually (not equally well) sufficiently
        significant with multiple pattern. This can especially happen in cases of
        pseudosymmetry and more frequently with an improperly calibrated system
        or false or inaccurate phase models e.g. (ferrite, austenite).
        Having such field is especially relevant for recent machine learning
        or dictionary based indexing schemes because in combination with
        phase_matching these fields communicate the results in a model-agnostic
        way.
        
        Depending on the n_phases_per_scan_point value phase_identifier and
        phase_matching arrays represent a collection of concatenated tuples,
        which are organized in sequence: The solutions for the 0-th scan point,
        the 1-th scan point, the n_sc - 1 th scan point and omitting tuples
        for those scan points with no phases according to n_phases_per_scan_point
      dimensions:
        rank: 1
        dim: (n_solutions,)
    phase_matching(NX_INT):
      unit: NX_UNITLESS
      doc: |
        One-dimensional array, pattern by pattern labelling the solutions found.
        The array n_phases_per_scan_point has to be specified because it details
        how the phase_identifier and the phase_matching arrays have to be interpreted.
        See documentation of phase_identifier for further details.
      dimensions:
        rank: 1
        dim: (n_solutions,)
    phase_matching_descriptor(NX_CHAR):
      doc: |
        Phase_matching is a descriptor for how well the solution matches or not.
        Examples can be confidence_index, mean_angular_deviation, some AI-based
        matching probability (other), i.e. the details are implementation-specific.
      enumeration: [undefined, confidence_index, mean_angular_deviation, other]
    rotation_set(NXrotation_set):
    
    # px is no one of the following two calibrated i) is not px*stepsize or ii) is not
    # px*stepsize + offset
    scan_point_positions(NX_NUMBER):
      unit: NX_LENGTH
      
      # we make this only required as people may not yet be so happy with
      # having to walk a graph from measurement -> path -> NXevent_data_em
      # -> em_lab/ebeam_deflector to retrieve the actual scan positions
      # although this would be cleaner, also scan_point_positions could be
      # an instance of NXcg_point_set with a depends_on pointing
      # to sample_reference_frame
      doc: |
        Calibrated center positions of each scan point
        in the sample surface reference system.
      dimensions:
        rank: 2
        dim: (n_sc, 2)
    indexing_rate(NX_NUMBER):
      unit: NX_DIMENSIONLESS
      doc: |
        Fraction of successfully indexed pattern with a phase
        not the null-phase vs the number_of_scan_points.
    number_of_scan_points(NX_UINT):
      unit: NX_UNITLESS
      doc: |
        Number of scan points in the original mapping.
    
    # odfID(NXmicrostructure_odf):
    # pfID(NXmicrostructure_pf):
    # ipfID(NXmicrostructure_ipf):
    # microstructureID(NXmicrostructure):
    # overview over the entire map, rediscretized on a tight aabb
    roi(NXdata):
      doc: |
        An overview of the entire ROI.
      descriptor(NX_CHAR):
        doc: |
          Descriptor representing the image contrast.
        
        # taking two examples (CTF and H5OINA choked completely of possibility to find s.th. conceptually common to plot
        enumeration: [band_contrast, confidence_index, mean_angular_deviation]
      
      # \@signal:  # data
      # \@axes:  # [axis_y, axis_x]
      # \@axis_x_indices: 0
      # \@axis_y_indices: 1
      # \@signal:
      # \@axes:
      # \@AXISNAME_indices:
      # \@long_name:
      title(NX_CHAR):
        doc: |
          Title of the default plot.
      data(NX_NUMBER):
        unit: NX_UNITLESS
        doc: |
          Descriptor values displaying the ROI.
        dimensions:
          rank: 2
          dim: (n_y, n_x)
        
        # n_0 slow 2, n_1 fast 1, rgb triplet is fastest 0
        # in axes fast to fastest
        # while for _indices fastest to fast
        \@long_name(NX_CHAR):
          doc: |
            Descriptor values.
      axis_y(NX_NUMBER):
        unit: NX_LENGTH
        doc: |
          Calibrated coordinate along the y-axis.
        dimensions:
          rank: 1
          dim: (n_y,)
        \@long_name(NX_CHAR):
          doc: |
            Label for the y axis
      axis_x(NX_NUMBER):
        unit: NX_LENGTH
        doc: |
          Calibrated coordinate along the x-axis.
        dimensions:
          rank: 1
          dim: (n_x,)
        \@long_name(NX_CHAR):
          doc: |
            Label for the x axis

# ++++++++++++++++++++++++++++++++++ SHA HASH ++++++++++++++++++++++++++++++++++
# 45aa2708048c78bc81f55a6ede151d65c04b0bee5d0cf4afbd404a21665f5b6d
# <?xml version='1.0' encoding='UTF-8'?>
# <?xml-stylesheet type="text/xsl" href="nxdlformat.xsl"?>
# <!--
# # NeXus - Neutron and X-ray Common Data Format
# #
# # Copyright (C) 2023-2025 NeXus International Advisory Committee (NIAC)
# #
# # This library is free software; you can redistribute it and/or
# # modify it under the terms of the GNU Lesser General Public
# # License as published by the Free Software Foundation; either
# # version 3 of the License, or (at your option) any later version.
# #
# # This library is distributed in the hope that it will be useful,
# # but WITHOUT ANY WARRANTY; without even the implied warranty of
# # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# # Lesser General Public License for more details.
# #
# # You should have received a copy of the GNU Lesser General Public
# # License along with this library; if not, write to the Free Software
# # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
# #
# # For further information, see http://www.nexusformat.org
# -->
# <definition xmlns="http://definition.nexusformat.org/nxdl/3.1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" category="base" type="group" name="NXem_ebsd" extends="NXem_method" xsi:schemaLocation="http://definition.nexusformat.org/nxdl/3.1 ../nxdl.xsd">
#     <symbols>
#         <symbol name="n_op">
#             <doc>
#                  Number of arguments per orientation for given parameterization.
#             </doc>
#         </symbol>
#         <symbol name="n_sc">
#             <doc>
#                  Number of scan points.
#             </doc>
#         </symbol>
#         <symbol name="n_z">
#             <doc>
#                  Number of pixel along the slowest changing dimension for a rediscretized, 
#                  i.e. standardized default plot orientation mapping.
#             </doc>
#         </symbol>
#         <symbol name="n_y">
#             <doc>
#                  Number of pixel along slow changing dimension for a rediscretized i.e.
#                  standardized default plot orientation mapping.
#             </doc>
#         </symbol>
#         <symbol name="n_x">
#             <doc>
#                  Number of pixel along fast changing dimension for a rediscretized i.e.
#                  standardized default plot orientation mapping.
#             </doc>
#         </symbol>
#         <symbol name="n_solutions">
#             <doc>
#                  Number of phase solutions
#             </doc>
#         </symbol>
#     </symbols>
#     <doc>
#          Base class method-specific for Electron Backscatter Diffraction (EBSD).
#          
#          The general procedure of an EBSD experiment is as follows.
#          Users load the specimen, collect first a coarse image of the surface.
#          Next, they set an approximate value for the calibrated working distance and
#          tilt the stage to set the desired diffraction conditions.
#          
#          Users then typically configure the microscope for collecting higher quality data
#          and push in the EBSD detector. Subsequently, they fine tune the illumination
#          and aberration corrector settings and select one or multiple ROIs for
#          the microscope to machine off automatically. They configure on-the-fly
#          indexing parameter and start the measurement queue.
#          
#          Nowadays, this is in most cases an automated process. The pattern
#          collection runs during the allocated microscope session until the
#          queue finishes or gets interrupted by errors or the next user terminates
#          sessions which run over time.
#          
#          Kikuchi pattern surplus eventually multi-modal detector signals are
#          collected and usually indexed on-the-fly. Patterns may be stored or not
#          so one should not assume that raw data are always stored.
#          
#          Results are stored in files, which afterwards are typically copied
#          automatically or manual for archival purposes to certain storage
#          locations or further consumption. The result of such an EBSD
#          measurement/experiment is a set of usually proprietary or open files
#          from technology partners.
#          
#          This :ref:`NXem_ebsd` base class is a proposal how to represent method-specific
#          data, metadata, and connections between these for the research field of
#          electron microscopy.
#          
#          More specifically, exemplified here for electron backscatter diffraction (EBSD)
#          we show how NeXus can be used to solve two key documentation issues so far
#          missing in the field of EBSD.
#          
#          Firstly, an instance of NXem_ebsd (such as a NeXus/HDF5 file which is formatted
#          according to NXem_ebsd) stores the connection between the microscope session and
#          the key datasets which are considered typically results of the various processing
#          steps involved when working with EBSD data.
#          
#          Different groups in NXem_ebsd make connections to data artifacts which were collected
#          when working with electron microscopes via the NXem application definition.
#          Using a file which stores information according to the NXem application definition
#          has the benefit that it connects the sample, references to the sample processing,
#          the user operating the microscope, details about the microscope session,
#          and details about the acquisition and eventual indexing of Kikuchi pattern,
#          associated overview images, like secondary electron or backscattered electron
#          images of the region-of-interest probed and many more pieces of information.
#          
#          Secondly, NXem_ebsd connects and stores the conventions and reference frames
#          which were used and which are the key to a correct mathematical interpretation
#          of every EBSD result. Otherwise, results would be ripped out of their context,
#          as it is the current situation with many traditional studies where EBSD data
#          were indexed on-the-fly and shared with the community only via sharing
#          the strongly processed results file in some technology-partner-specific file
#          format but without communicating all conventions or relying on the assumptions
#          that colleagues likely know these conventions even though multiple definitions
#          are possible.
#          
#          NXem_ebsd covers experiments with one-, two-dimensional, and so-called three-
#          dimensional EBSD datasets. The third dimension is either time (in the case of
#          quasi in-situ experiments) or space (in the case of serial-sectioning) methods
#          where a combination of mechanical or ion milling is used repetitively to measure
#          the same region-of-interest at different depth increments. Material removal
#          can be achieved with electron or ion polishing, using manual
#          steps or using automated equipment like a robot system.
#          
#          Three-dimensional experiments require to follow a sequence of specimen, surface
#          preparation, and data collection steps. By nature these methods are destructive
#          in that they either require the removal of the previously measured material region
#          or that the sample surface can degrade due to e.g. contamination or other
#          electron-matter interaction.
#          
#          For three-dimensional EBSD, multiple two-dimensional EBSD orientation mappings are
#          combined into one reconstructed stack. That is serial-sectioning is mainly a
#          computational workflow. Users collect data for each serial sectioning step
#          via an experiment. This assures that data for associated microscope sessions
#          and steps of data processing stay connected and contextualized.
#          
#          Eventual tomography methods also use such a workflow because first diffraction
#          images are collected (e.g. with X-ray) and then these imagres are indexed and
#          computed into a 3D orientation mapping. The here proposed NXem_ebsd application
#          definition contains conceptual ideas how this splitting between measurement and
#          post-processing can be granularized also for such X-ray-based techniques, whether
#          it be 3DXRD or HEDM.
#          
#          This concept is related to term `Electron Backscatter Diffraction`_ of the EMglossary standard.
#          
#          .. _Electron Backscatter Diffraction: https://purls.helmholtz-metadaten.de/emg/EMG_00000019
#     </doc>
#     <!--(NXcoordinate_system):-->
#     <group name="gnomonic_reference_frame" type="NXcoordinate_system">
#         <doc>
#              Details about the gnomonic (projection) reference frame.
#              
#              It is assumed that the configuration is inspected by looking towards the sample surface.
#              If a detector is involved, it is assumed that the configuration is inspected from a position
#              that is located behind this detector.
#              
#              If any of these assumptions is not met, the user is required to explicitly state this.
#              
#              Reference DOI: 10.1016/j.matchar.2016.04.008 suggests to label the
#              base vectors of this coordinate system as Xg, Yg, Zg.
#         </doc>
#         <field name="origin" type="NX_CHAR">
#             <doc>
#                  Origin of the gnomonic_projection_reference_frame.
#                  
#                  Reference DOI: 10.1016/j.matchar.2016.04.008 suggests to
#                  assume that this is coordinate Xg = 0, Yg = 0, Zg = 0.
#             </doc>
#             <enumeration>
#                 <item value="undefined"/>
#                 <item value="in_the_pattern_centre"/>
#             </enumeration>
#         </field>
#         <field name="x_direction" type="NX_CHAR">
#             <doc>
#                  Direction of the positively pointing x-axis base vector of the
#                  gnomonic_reference_frame.
#             </doc>
#             <enumeration>
#                 <item value="undefined"/>
#                 <item value="north"/>
#                 <item value="east"/>
#                 <item value="south"/>
#                 <item value="west"/>
#                 <item value="in"/>
#                 <item value="out"/>
#             </enumeration>
#         </field>
#         <field name="y_direction" type="NX_CHAR">
#             <doc>
#                  Direction of the positively pointing y-axis base vector of the
#                  gnomonic_reference_frame.
#             </doc>
#             <enumeration>
#                 <item value="undefined"/>
#                 <item value="north"/>
#                 <item value="east"/>
#                 <item value="south"/>
#                 <item value="west"/>
#                 <item value="in"/>
#                 <item value="out"/>
#             </enumeration>
#         </field>
#         <field name="z_direction" type="NX_CHAR">
#             <doc>
#                  Direction of the positively pointing z-axis base vector of the
#                  gnomonic_reference_frame.
#             </doc>
#             <enumeration>
#                 <item value="undefined"/>
#                 <item value="north"/>
#                 <item value="east"/>
#                 <item value="south"/>
#                 <item value="west"/>
#                 <item value="in"/>
#                 <item value="out"/>
#             </enumeration>
#         </field>
#     </group>
#     <group name="pattern_centre" type="NXprocess">
#         <doc>
#              Details about the definition of the pattern centre as a special point in the gnomonic_reference_frame.
#              
#              Keep in mind that the gnomonic space is in virtually all cases embedded in the detector space.
#              Specifically, the XgYg plane is defined such that it is laying inside the XdYd plane
#              (of the detector reference frame).
#              
#              When the normalization direction is the same as e.g. the detector x-axis direction one
#              effectively normalizes in fractions of the width of the detector.
#              
#              The issue with terms like width and height is that these degenerate if the detector
#              region-of-interest is square-shaped. This is why instead of referring to width and height
#              one should report as if one were to measure practically with a ruler and one is specific
#              about in which direction positive distances are measured.
#              
#              For the concepts used to specify the boundary_convention it is assumed that the
#              region-of-interest is defined by a rectangle, referring to the direction of outer-unit
#              normals to the respective edges of this rectangle.
#         </doc>
#         <field name="x_boundary_convention" type="NX_CHAR">
#             <doc>
#                  From which border of the EBSP (in the detector reference frame) is the pattern
#                  centre's x-position (PCx) measured.
#             </doc>
#             <enumeration>
#                 <item value="undefined"/>
#                 <item value="top"/>
#                 <item value="right"/>
#                 <item value="bottom"/>
#                 <item value="left"/>
#             </enumeration>
#         </field>
#         <field name="x_normalization_direction" type="NX_CHAR">
#             <doc>
#                  In which direction are positive values for the x-axis coordinate value measured
#                  from the specified boundary.
#             </doc>
#             <enumeration>
#                 <item value="undefined"/>
#                 <item value="north"/>
#                 <item value="east"/>
#                 <item value="south"/>
#                 <item value="west"/>
#             </enumeration>
#         </field>
#         <field name="y_boundary_convention" type="NX_CHAR">
#             <doc>
#                  From which border of the EBSP (in the detector reference frame) is the pattern
#                  centre's y-position (PCy) measured.
#             </doc>
#             <enumeration>
#                 <item value="undefined"/>
#                 <item value="top"/>
#                 <item value="right"/>
#                 <item value="bottom"/>
#                 <item value="left"/>
#             </enumeration>
#         </field>
#         <field name="y_normalization_direction" type="NX_CHAR">
#             <doc>
#                  In which direction are positive values for the y-axis coordinate value measured
#                  from the specified boundary.
#             </doc>
#             <enumeration>
#                 <item value="undefined"/>
#                 <item value="north"/>
#                 <item value="east"/>
#                 <item value="south"/>
#                 <item value="west"/>
#             </enumeration>
#         </field>
#     </group>
#     <!--distance_convention:
# doc: |
# How is the third of the three pattern centre parameter values,
# the (distance) parameter DD, normalized. Which convention
# is followed. We are aware that specifying one of the options here
# also implicitly comes with conventions for some of the parameter
# requested in this ELN. For now we would rather like to ask
# the users though to be specific also to learn how such an ELN
# will be used in practice.
# enumeration: [undefined, Bruker, JEOL, FEI, Oxford]-->
#     <group name="measurement" type="NXprocess">
#         <doc>
#              This group documents relevant details about the conditions and the tools
#              used for measuring a stack of Kikuchi diffraction pattern with an
#              electron microscope.
#              
#              The most frequently collected EBSD data are captured for rectangular
#              regions-of-interested which are sampled with regular square or
#              hexagon-shaped pixels.
#         </doc>
#         <field name="time" type="NX_NUMBER" units="NX_TIME">
#             <doc>
#                  Physical time since the beginning of a timestamp that is required to be
#                  same for all experiments in the set. The purpose of this marker is
#                  to identify how all experiments in the set need to be arranged
#                  sequentially based on the time elapsed.
#                  The time is relevant to sort e.g. experiments of consecutive quasi
#                  in-situ experiments where a measurement was e.g. taken after 0 minutes,
#                  30 minutes, 6 hours, or 24 hours of annealing.
#             </doc>
#             <attribute name="epoch_start" type="NX_CHAR">
#                 <doc>
#                      Timestamp relative to which time was counted to aid
#                      converting between time and timestamp.
#                 </doc>
#             </attribute>
#         </field>
#         <!--(NXtransformations):
#   doc: |
#     Transformation which details where the region-of-interest described under
#     indexing is located in absolute coordinates and rotation with respect
#     to which coordinate system.
# pattern_available(NX_BOOLEAN):
#   doc: |
#     True if pattern were stored and are retrieveable via depends_on or source.-->
#         <field name="depends_on" type="NX_CHAR">
#             <doc>
#                  If available and it is stored in an instance of an application definition this field
#                  specifies the path to an instance of :ref:`NXdata` where the measured patterns
#                  are stored.
#             </doc>
#         </field>
#         <group name="source" type="NXserialized">
#             <doc>
#                  Reference (e.g. path and filename) to an existent data artifact which
#                  stores either the measured pattern or input (already processed EBSD data).
#             </doc>
#         </group>
#     </group>
#     <group name="simulation" type="NXprocess">
#         <doc>
#              This group documents relevant details about the conditions and the tools
#              used for simulating a stack of Kikuchi diffraction pattern with some
#              physical model.
#              
#              This group should not be confused with a group named simulation that
#              is however an instance of NXem_sim. Instead, the simulation group here
#              should be used if (e.g. instead of a measurement) a stack of pattern
#              were simulated that one wishes to use for indexing patterns.
#              
#              In many practical cases where pattern are analyzed on-the-fly and dictionary
#              indexing strategies are used, so-called master pattern(s) are used to compare
#              measured or simulated pattern with the master pattern. In this case,
#              master pattern are the result of a computer simulation and thus should
#              be stored using an own properly documented entry within a simulation
#              group as an instance of :ref:`NXem_sim`.
#         </doc>
#         <field name="depends_on" type="NX_CHAR">
#             <doc>
#                  If available and it is stored in an instance of an application definition this field specifies
#                  the path to an instance of :ref:`NXimage_set` where the simulated patterns are stored.
#             </doc>
#         </field>
#         <group name="source" type="NXserialized">
#             <doc>
#                  Reference (e.g. path and filename) to an existent digital resource which
#                  stores either the pattern or input (already processed EBSD data)
#                  which is now processed further as described by this NXem_ebsd instance.
#             </doc>
#         </group>
#     </group>
#     <group name="calibration" type="NXprocess">
#         <doc>
#              The EBSD system, including components like the electron gun, pole-piece,
#              stage tilting, EBSD detector, and the gnomonic projection have to be
#              calibrated to achieve reliable indexing results.
#              
#              Specifically, the gnomonic projection has to be calibrated.
#              Typically, silicon or quartz crystals are used for this purpose.
#              
#              Considering a system is well-calibrated, it is much more frequently the
#              case in practice that users assume the system is calibrated (and thus usable)
#              vs. they perform the calibration of the EBSD system.
#              
#              In the first case, the user assumes that the principle geometry of the
#              hardware components and the settings in the control and EBSD pattern
#              acquisition software has been calibrated. Consequently, users pick from
#              an existent library of phase candidates, i.e.
#              :ref:`NXcrystal_structure` instances. Examples are
#              reflector models as stored in CRY files (HKL/Channel 5/Flamenco).
#              
#              In the second case, users calibrate the system during the session
#              using standards (silicon, quartz, or other common specimens).
#              There is usually one person in each lab responsible for doing such
#              calibrations. Often this person or technician is also in charge of
#              configuring the graphical user interface and software with which most
#              users control and perform their analyses.
#              
#              For EBSD this has key implications: Taking TSL OIM/EDAX as an example,
#              the conventions how orientations are stored is affected by how the
#              reference frames are configured and this setup is made at the level
#              of the GUI software.
#              
#              Unfortunately, these pieces of information are not necessarily stored
#              in the results files. In effect, key conventions become disconnected
#              from the data so it remains the users' obligation to remember these
#              settings or write these down in a lab notebook. Otherwise, these metadata
#              get lost. All these issues are a motivation and problem which
#              :ref:`NXem_ebsd` solves in that all conventions can be specified explicitly.
#         </doc>
#         <field name="depends_on" type="NX_CHAR">
#             <doc>
#                  If available and it is stored in an instance of an application definition this field specifies
#                  the path to an instance of :ref:`NXem_msr` where calibration is stored.
#             </doc>
#         </field>
#         <group name="source" type="NXserialized">
#             <doc>
#                  Reference to a digital resource where the calibration is stored.
#             </doc>
#         </group>
#     </group>
#     <group name="indexing" type="NXprocess">
#         <doc>
#              Indexing is a data processing step performed either after or while
#              (on-the-fly) the beam scans the specimen. The resulting method is also
#              known as orientation imaging microscopy (OIM).
#              
#              Different algorithms can be used to index EBSD pattern. Common to them
#              is the computational step where simulated reference pattern are compared
#              with measured or simulated patterns. These latter patterns are referred
#              to via the measurement or simulation groups of this base class.
#              
#              Quality descriptors are defined based on which an indexing algorithm
#              yields a quantitative measure of how similar measured and reference
#              pattern are, and thus if no, one, or multiple so-called solutions
#              were found.
#              
#              Assumed or simulated pattern are simulated using kinematic or dynamical
#              theory of electron diffraction delivering master pattern.
#              
#              The Hough transform is essentially a discretized Radon transform (for details see `M. van Ginkel et al. &lt;https://www.semanticscholar.org/paper/A-short-introduction-to-the-Radon-and-Hough-and-how-Ginkel/fb6226f606cad489a15e38ed961c419037ccc858&gt;`_).
#              Recently, dictionary-based indexing methods are increasingly becoming used
#              partly driven by the interest to use artificial intelligence algorithms.
#         </doc>
#         <group name="source" type="NXserialized">
#             <doc>
#                  This group enables to establish a logical connection between previous
#                  processing steps or on-the-fly-performed indexing of the EBSD map.
#                  Typically these processing steps are performed with commercial software.
#                  Therefore, in many cases a results file from this indexing is often
#                  all that is communicated and saved. These are typically files in a format
#                  specific to the instrument and its configuration.
#                  
#                  Typical file formats are CPR/CRC, ANG, OSC, HDF5, H5EBSD, EDAXH5.
#             </doc>
#         </group>
#         <field name="method" type="NX_CHAR">
#             <doc>
#                  Principal algorithm used for indexing.
#             </doc>
#             <enumeration>
#                 <item value="undefined"/>
#                 <item value="hough_transform"/>
#                 <item value="dictionary"/>
#                 <item value="radon_transform"/>
#                 <item value="other"/>
#             </enumeration>
#         </field>
#         <group name="background_correction" type="NXprocess">
#             <doc>
#                  Details about the background correction applied to each Kikuchi pattern.
#             </doc>
#         </group>
#         <group name="binning" type="NXprocess">
#             <doc>
#                  Binning i.e. downsampling of the pattern.
#             </doc>
#         </group>
#         <group name="parameter" type="NXprocess">
#             <doc>
#                  Specific parameter relevant only for certain algorithms used.
#             </doc>
#         </group>
#         <group name="phaseID" type="NXcrystal_structure">
#             <doc>
#                  Details for each phase used as a model with which the patterns were
#                  indexed. Instances of :ref:`NXcrystal_structure` in this group must
#                  have the group name prefix phase. The identifier in the name is an
#                  integer. We start counting from 1 because the value 0 is reserved for
#                  the special phase that is the null-model, i.e. the null phase, notIndexed.
#             </doc>
#         </group>
#         <field name="status" type="NX_UINT" units="NX_UNITLESS">
#             <doc>
#                  Which return value did the indexing algorithm yield for each scan point.
#                  Practically useful is to use an uint8 mask.
#                  
#                  * 0 - Not analyzed
#                  * 1 - Too high angular deviation
#                  * 2 - No solution
#                  * 100 - Success
#                  * 255 - Unexpected errors
#             </doc>
#             <dimensions rank="1">
#                 <dim index="1" value="n_sc"/>
#             </dimensions>
#         </field>
#         <field name="n_phases_per_scan_point" type="NX_INT" units="NX_UNITLESS">
#             <doc>
#                  How many phases i.e. crystal structure models were used to index each
#                  scan point if any? Let's assume an example to explain how this field
#                  should be used: In the simplest case users collected one pattern for
#                  each scan point and have indexed using one phase, i.e. one instance
#                  of an NXem_ebsd_crystal_structure_model.
#                  
#                  In another example users may have skipped some scan points (not indexed)
#                  them at all) and/or used differing numbers of phases for different scan
#                  points.
#                  
#                  The cumulated of this array decodes how phase_identifier and phase_matching
#                  arrays have to be interpreted. In the simplest case (one pattern per scan
#                  point, and all scan points indexed using that same single phase model),
#                  phase_identifier has as many entries as scan points
#                  and phase_matching has also as many entries as scan points.
#             </doc>
#             <dimensions rank="1">
#                 <dim index="1" value="n_sc"/>
#             </dimensions>
#         </field>
#         <field name="phase_identifier" type="NX_INT" units="NX_UNITLESS">
#             <doc>
#                  The array n_phases_per_scan_point details how the phase_identifier
#                  and the phase_matching arrays have to be interpreted.
#                  
#                  For the example with a single phase phase_identifier has trivial
#                  values either 0 (no solution) or 1 (solution matching
#                  sufficiently significant with the model for phase 1).
#                  
#                  When there are multiple phases, it is possible (although not frequently
#                  needed) that a pattern matches eventually (not equally well) sufficiently
#                  significant with multiple pattern. This can especially happen in cases of
#                  pseudosymmetry and more frequently with an improperly calibrated system
#                  or false or inaccurate phase models e.g. (ferrite, austenite).
#                  Having such field is especially relevant for recent machine learning
#                  or dictionary based indexing schemes because in combination with
#                  phase_matching these fields communicate the results in a model-agnostic
#                  way.
#                  
#                  Depending on the n_phases_per_scan_point value phase_identifier and
#                  phase_matching arrays represent a collection of concatenated tuples,
#                  which are organized in sequence: The solutions for the 0-th scan point,
#                  the 1-th scan point, the n_sc - 1 th scan point and omitting tuples
#                  for those scan points with no phases according to n_phases_per_scan_point
#             </doc>
#             <dimensions rank="1">
#                 <dim index="1" value="n_solutions"/>
#             </dimensions>
#         </field>
#         <field name="phase_matching" type="NX_INT" units="NX_UNITLESS">
#             <doc>
#                  One-dimensional array, pattern by pattern labelling the solutions found.
#                  The array n_phases_per_scan_point has to be specified because it details
#                  how the phase_identifier and the phase_matching arrays have to be interpreted.
#                  See documentation of phase_identifier for further details.
#             </doc>
#             <dimensions rank="1">
#                 <dim index="1" value="n_solutions"/>
#             </dimensions>
#         </field>
#         <field name="phase_matching_descriptor" type="NX_CHAR">
#             <doc>
#                  Phase_matching is a descriptor for how well the solution matches or not.
#                  Examples can be confidence_index, mean_angular_deviation, some AI-based
#                  matching probability (other), i.e. the details are implementation-specific.
#             </doc>
#             <enumeration>
#                 <item value="undefined"/>
#                 <item value="confidence_index"/>
#                 <item value="mean_angular_deviation"/>
#                 <item value="other"/>
#             </enumeration>
#         </field>
#         <group name="rotation_set" type="NXrotation_set"/>
#         <!--
# px is no one of the following two calibrated i) is not px*stepsize or ii) is not
# px*stepsize + offset
# -->
#         <field name="scan_point_positions" type="NX_NUMBER" units="NX_LENGTH">
#             <!--
# we make this only required as people may not yet be so happy with
# having to walk a graph from measurement -> path -> NXevent_data_em
# -> em_lab/ebeam_deflector to retrieve the actual scan positions
# although this would be cleaner, also scan_point_positions could be
# an instance of NXcg_point_set with a depends_on pointing
# to sample_reference_frame
# -->
#             <doc>
#                  Calibrated center positions of each scan point
#                  in the sample surface reference system.
#             </doc>
#             <dimensions rank="2">
#                 <dim index="1" value="n_sc"/>
#                 <dim index="2" value="2"/>
#             </dimensions>
#         </field>
#         <field name="indexing_rate" type="NX_NUMBER" units="NX_DIMENSIONLESS">
#             <doc>
#                  Fraction of successfully indexed pattern with a phase
#                  not the null-phase vs the number_of_scan_points.
#             </doc>
#         </field>
#         <field name="number_of_scan_points" type="NX_UINT" units="NX_UNITLESS">
#             <doc>
#                  Number of scan points in the original mapping.
#             </doc>
#         </field>
#         <!--odfID(NXmicrostructure_odf):
# pfID(NXmicrostructure_pf):
# ipfID(NXmicrostructure_ipf):
# microstructureID(NXmicrostructure):
# overview over the entire map, rediscretized on a tight aabb-->
#         <group name="roi" type="NXdata">
#             <doc>
#                  An overview of the entire ROI.
#             </doc>
#             <field name="descriptor" type="NX_CHAR">
#                 <doc>
#                      Descriptor representing the image contrast.
#                 </doc>
#                 <!--taking two examples (CTF and H5OINA choked completely of possibility to find s.th. conceptually common to plot-->
#                 <enumeration>
#                     <item value="band_contrast"/>
#                     <item value="confidence_index"/>
#                     <item value="mean_angular_deviation"/>
#                 </enumeration>
#             </field>
#             <!--\@signal:  # data
# \@axes:  # [axis_y, axis_x]
# \@axis_x_indices: 0
# \@axis_y_indices: 1
# \@signal:
# \@axes:
# \@AXISNAME_indices:
# \@long_name:-->
#             <field name="title" type="NX_CHAR">
#                 <doc>
#                      Title of the default plot.
#                 </doc>
#             </field>
#             <field name="data" type="NX_NUMBER" units="NX_UNITLESS">
#                 <doc>
#                      Descriptor values displaying the ROI.
#                 </doc>
#                 <dimensions rank="2">
#                     <dim index="1" value="n_y"/>
#                     <dim index="2" value="n_x"/>
#                 </dimensions>
#                 <!--n_0 slow 2, n_1 fast 1, rgb triplet is fastest 0
# in axes fast to fastest
# while for _indices fastest to fast-->
#                 <attribute name="long_name" type="NX_CHAR">
#                     <doc>
#                          Descriptor values.
#                     </doc>
#                 </attribute>
#             </field>
#             <field name="axis_y" type="NX_NUMBER" units="NX_LENGTH">
#                 <doc>
#                      Calibrated coordinate along the y-axis.
#                 </doc>
#                 <dimensions rank="1">
#                     <dim index="1" value="n_y"/>
#                 </dimensions>
#                 <attribute name="long_name" type="NX_CHAR">
#                     <doc>
#                          Label for the y axis
#                     </doc>
#                 </attribute>
#             </field>
#             <field name="axis_x" type="NX_NUMBER" units="NX_LENGTH">
#                 <doc>
#                      Calibrated coordinate along the x-axis.
#                 </doc>
#                 <dimensions rank="1">
#                     <dim index="1" value="n_x"/>
#                 </dimensions>
#                 <attribute name="long_name" type="NX_CHAR">
#                     <doc>
#                          Label for the x axis
#                     </doc>
#                 </attribute>
#             </field>
#         </group>
#     </group>
# </definition>
