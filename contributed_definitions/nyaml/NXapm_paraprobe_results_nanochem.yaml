category: application
doc: |
  Results of a paraprobe-nanochem tool run.
symbols:
  doc: The symbols used in the schema to specify e.g. dimensions of arrays.
  n_ions: The total number of ions in the reconstruction.
  n_atomic: The total number of atoms in the atomic_decomposition match filter.
  n_isotopic: The total number of isotopes in the isotopic_decomposition match filter.
  d: The dimensionality of the delocalization grid.
  c: |
    The cardinality/total number of cells/grid points in the delocalization grid.
  # c_tri_soup: |
  #   The cardinality/total number of triangles in the triangle soup.
  n_f_tri_xdmf: The total number of XDMF values to represent all faces of triangles via XDMF.
  n_feature_dict: The total number of entries in a feature dictionary.
  n_speci: The total number of member distinguished when reporting composition.
NXapm_paraprobe_results_nanochem:
  (NXentry):
    # by default for appdefs the value of the exists keyword is required
    # unless it is explicitly specified differently
    exists: [min, 1, max, 1]
    \@version:
      doc: Version specifier of this application definition.

# ##MK::begin of the tool-specific section
    definition:
      doc: Official NeXus NXDL schema with which this file was written.
      enumeration: [NXapm_paraprobe_results_nanochem]
# ##MK::end of the tool-specific section

    program:
      doc: |
        Given name of the program/software/tool with which this NeXus
        (configuration) file was generated.
      \@version:
        doc: |
          Ideally program version plus build number, or commit hash or description
          of ever persistent resources where the source code of the program and
          build instructions can be found so that the program can be configured
          ideally in such a manner that the result of this computational process
          is recreatable in the same deterministic manner.
    analysis_identifier:
      doc: |
        Ideally, a (globally persistent) unique identifier for referring
        to this analysis.
    analysis_description:
      exists: optional
      doc: |
        Possibility for leaving a free-text description about this analysis.
    start_time(NX_DATE_TIME):
      doc: |
        ISO 8601 formatted time code with local time zone offset to UTC
        information included when the analysis behind this results file
        was started, i.e. the paraprobe-tool executable started as a process.
    end_time(NX_DATE_TIME):
      doc: |
        ISO 8601 formatted time code with local time zone offset to UTC
        information included when the analysis behind this results file
        were completed and the paraprobe-tool executable exited as a process.
    config_filename:
      doc: |
        The absolute path and name of the config file for this analysis.
      \@version:
        doc: |
          At least SHA256 strong hash of the specific config_file for
          tracking provenance.
    results_path:
      exists: optional
      doc: |
        Path to the directory where the tool should store NeXus/HDF5 results
        of this analysis. If not specified results will be stored in the
        current working directory.
    status(NX_CHAR):
      doc: |
        A statement whether the paraprobe-tool executable managed to
        process the analysis or failed prematurely.
        
        This status is written to the results file after the end_time
        at which point the executable must no longer compute analyses.
        Only when this status message is present and shows `success`, the
        user should consider the results. In all other cases, it might be
        that the executable has terminated prematurely or another error
        occurred.
      enumeration: [success, failure]
    (NXuser):
      exists: optional
      doc: |
        If used, contact information and eventually details
        of at least the person who performed this analysis.
      name:
      affiliation:
        exists: recommended
      address:
        exists: optional
      email:
        exists: recommended
      orcid:
        exists: recommended
      orcid_platform:
        exists: recommended
      telephone_number:
        exists: optional
      role:
        exists: recommended
      social_media_name:
        exists: optional
      social_media_platform:
        exists: optional
    (NXcoordinate_system_set):
      doc: |
        Details about the coordinate system conventions used.
        If nothing else is specified we assume that there
        has to be at least one set of NXtransformations named
        paraprobe defined, which specifies the coordinate system.
        In which all positions are defined.
      # ##MK::define also reconstruction coordinate system and
      # ##MK::map between the two
      (NXtransformations):
        exists: [min, 1, max, infty]
        doc: |
          The individual coordinate systems which should be used.
          Field names should be prefixed with the following controlled terms
          indicating which individual coordinate system is described:
          
          * paraprobe
          * lab
          * specimen
          * laser
          * leap
          * detector
          * recon
          

# ##MK::begin of the tool-specific section
    (NXprocess):
      exists: [min, 0, max, 1]
      window(NXcs_filter_boolean_mask):
        doc: |
          A bitmask which identifies which of the ions in the dataset were
          analyzed during this process.
        number_of_ions(NX_UINT):
          doc: |
            Number of ions covered by the mask.
            The mask value for most may be 0.
          unit: NX_UNITLESS
        bitdepth(NX_UINT):
          doc: |
            Number of bits assumed matching on a default datatype.
            (e.g. 8 bits for a C-style uint8).
          unit: NX_UNITLESS
        mask(NX_UINT):
          doc: |
            The unsigned integer array representing the content of the mask.
            If padding is used, padded bits are set to 0. The mask is for
            convenience always as large as the entire dataset as it will
            be stored compressed anyway. The convenience feature with this
            is that then the mask can be decoded with numpy and mirrored
            against the evaporation_id array and one immediately can filter
            out all points that were used by the paraprobe-toolbox executable.
            The length of the array adds to the next unsigned integer
            if the number of ions in the dataset is not an integer
            multiple of the bitdepth (padding).
          unit: NX_UNITLESS
          dimensions:
            rank: 1
            dim: [[1, n_ions]]

      iso_surface_analysis(NXprocess):
        exists: [min, 0, max, infty]
        delocalization(NXdelocalization):
          weighting_model:
            doc: |
              The weighting model specifies how mark data are mapped to a weight
              per point/ion. For atom probe microscopy (APM) mark data are e.g.
              which iontype an ion has. As an example, different models are used
              which account differently for the multiplicity of a point/ion
              during delocalization:
              
              * unity, all points/ions get the same weight 1.
              * atomic_decomposition, points get as much weight as they
                have atoms of a type in atomic_decomposition_rule,
              * isotope_decomposition, points get as much weight as they have
                isotopes of a type in isotopic_decomposition_rule.
              
            enumeration: [unity, atomic_decomposition, isotopic_decomposition]
          # if weighting_model == atomic_decomposition needs atomic_decomposition_rule
          # if weighting_model == isotopic_decomposition needs isotopic_decomposition_rule
          atomic_decomposition_rule(NXmatch_filter):
            exists: optional  # but required when weighting_model is atomic_decomposition
            doc: |
              A list of elements (via proton number) to consider for the
              atomic_decomposition weighting model.
              Elements must exist in the periodic table of elements and be
              specified by their number of protons.
              Values in match are isotope hash values using the following
              hashing rule $H = Z + 256*N$ with $Z$ the number of protons
              and $N$ the number of neutrons of the isotope.
              In the case of elements this hashing rule has the advantage
              that for elements the proton number is their hash value because
              N is zero.
            method:
              doc: |
                Meaning of the filter:
                Whitelist specifies which entries with said value to include.
                Entries with all other values will be filtered out.
                
                Blacklist specifies which entries with said value to exclude.
                Entries with all other values will be included.
              enumeration: [whitelist, blacklist]
            match(NX_NUMBER):
              doc: |
                Array of values to filter according to method. For example,
                if the filter specifies [1, 5, 6] and method is whitelist,
                only entries with values matching 1, 5 or 6 will be processed.
                All other entries will be filtered out/not considered.
              unit: NX_UNITLESS
              dimensions:
                rank: 1
                dim: [[1, n_atomic]]
          isotopic_decomposition_rule(NXmatch_filter):
            exists: optional  # but required when weighting model is isotopic_decomposition
            doc: |
              A list of isotopes (via proton and neutron number) to consider
              for the isotopic_decomposition weighting model.
              Isotopes must exist in the nuclid table.
              Values in match are isotope hash values using the following
              hashing rule $H = Z + 256*N$ with $Z$ the number of protons
              and $N$ the number of neutrons of the isotope.
            method:
              doc: |
                Meaning of the filter:
                Whitelist specifies which entries with said value to include.
                Entries with all other values will be filtered out.
                
                Blacklist specifies which entries with said value to exclude.
                Entries with all other values will be included.
              enumeration: [whitelist, blacklist]
            match(NX_NUMBER):
              doc: |
                Array of values to filter according to method. For example,
                if the filter specifies [1, 5, 6] and method is whitelist,
                only entries with values matching 1, 5 or 6 will be processed.
                All other entries will be filtered out/not considered.
              unit: NX_UNITLESS
              dimensions:
                rank: 1
                dim: [[1, n_isotopic]]
          normalization(NX_CHAR):
            doc: |
              How results of the kernel-density estimation were computed
              into quantities. By default the tool computes the total number
              (intensity) of ions or elements. Alternatively the tool can compute
              the total intensity, the composition, or the concentration of the
              ions/elements specified by the white list of elements in each voxel.
            enumeration: [total, candidates, composition, concentration]
          weight(NX_NUMBER):
            exists: optional
            doc: |
              Weighting factor, in atom probe, often termed multiplicity.
              The weighting factor is the multiplier with which the integrated
              intensity contribution from the point/ion gets multiplied.
              The delocalization computes the integrated intensity for each
              grid cell. Effectively, this is an explicitly evaluated kernel
              method where each specific position of an ion is replaced by a
              smoothing kernel. For atom probe weights are positive and integer
              specifically the multiplicity of the ion, in accordance with the
              respective rulesets as defined by weighting_model.
            unit: NX_DIMENSIONLESS
            dimensions:
              rank: 1
              dim: [[1, n_ions]]
          grid(NXcg_grid):
            doc: |
              The discretized domain/grid on which the delocalization is applied.
            dimensionality(NX_POSINT):
              unit: NX_UNITLESS
              enumeration: [1, 2, 3]
            cardinality(NX_POSINT):
              doc: The total number of cells/voxels of the grid.
              unit: NX_UNITLESS
            origin(NX_NUMBER):
              dimensions:
                rank: 1
                dim: [[1, d]]
            symmetry:
              doc: |
                The symmetry of the lattice defining the shape of the unit cell.
              enumeration: [cubic]
            cell_dimensions(NX_NUMBER):
              doc: |
                The unit cell dimensions according to the coordinate system
                defined under coordinate_system.
              unit: NX_LENGTH
              dimensions:
                rank: 1
                dim: [[1, d]]
            extent(NX_POSINT):
              doc: |
                Number of unit cells along each of the d unit vectors.
                The total number of cells, or grid points has to be the cardinality.
                If the grid has an irregular number of grid positions in each direction,
                as it could be for instance the case of a grid where all grid points
                outside some masking primitive are removed, this extent field should
                not be used. Instead use the coordinate field.
              unit: NX_UNITLESS
              dimensions:
                rank: 1
                dim: [[1, d]]
              # (NXtransformations):
            coordinate_system(NX_CHAR):
              exists: optional
              doc: |
                Reference to or definition of a coordinate system with
                which the positions and directions are interpretable.
              # should constraints on the grid be place here or not
            identifier_offset(NX_INT):
              doc: |
                Integer which specifies the first index to be used for
                distinguishing identifiers for cells. Identifiers are defined
                either implicitly or explicitly. For implicit indexing the
                identifiers are defined on the interval
                [identifier_offset, identifier_offset+c-1].
                For explicit indexing the identifier array has to be defined.
              unit: NX_UNITLESS
            bounding_box(NXcg_hexahedron_set):
              doc: |
                A tight axis-aligned bounding box about the grid.
              is_axis_aligned(NX_BOOLEAN):
                doc: |
                  For atom probe should be set to true.
                unit: NX_UNITLESS
              identifier_offset(NX_INT):
                doc: |
                  Integer which specifies the first index to be used for distinguishing
                  hexahedra. Identifiers are defined either implicitly
                  or explicitly. For implicit indexing the identifiers are defined on the
                  interval [identifier_offset, identifier_offset+c-1].
                  For explicit indexing the identifier array has to be defined.
                unit: NX_UNITLESS
              hexahedron(NXcg_face_list_data_structure):
                vertex_identifier_offset(NX_INT):
                  doc: |
                    Integer which specifies the first index to be used for distinguishing
                    identifiers for vertices. Identifiers are defined either implicitly
                    or explicitly. For implicit indexing the identifiers are defined on the
                    interval [identifier_offset, identifier_offset+c-1].
                    For explicit indexing the identifier array has to be defined.
                  unit: NX_UNITLESS
                face_identifier_offset(NX_INT):
                  doc: |
                    Integer which specifies the first index to be used for distinguishing
                    identifiers for faces. Identifiers are defined either implicitly
                    or explicitly. For implicit indexing the identifiers are defined on the
                    interval [identifier_offset, identifier_offset+c-1].
                    For explicit indexing the identifier array has to be defined.
                  unit: NX_UNITLESS
                vertices(NX_NUMBER):
                  doc: |
                    Positions of the vertices.
                    
                    Users are encouraged to reduce the vertices to unique set of positions
                    and vertices as this supports a more efficient storage of the geometry data.
                    It is also possible though to store the vertex positions naively in which
                    case vertices_are_unique is likely False.
                    Naively here means that one for example stores each vertex of a triangle
                    mesh even though many vertices are shared between triangles and thus
                    the positions of these vertices do not have to be duplicated.
                  unit: NX_LENGTH
                  dimensions:
                    rank: 2
                    dim: [[1, 8], [2, 3]]
                faces(NX_NUMBER):
                  doc: |
                    Array of identifiers from vertices which describe each face.
                    
                    The first entry is the identifier of the start vertex of the first face,
                    followed by the second vertex of the first face, until the last vertex
                    of the first face. Thereafter, the start vertex of the second face, the
                    second vertex of the second face, and so on and so forth.
                    
                    Therefore, summating over the number_of_vertices, allows to extract
                    the vertex identifiers for the i-th face on the following index interval
                    of the faces array: [$\sum_i = 0}^{i = n-1}$, $\sum_{i=0}^{i = n}$].
                  unit: NX_UNITLESS
                  dimensions:
                    rank: 2
                    dim: [[1, 6], [2, 4]]
                xdmf_topology(NX_UINT):
                  doc: |
                    Six equally formatted sextets chained together. For each
                    sextett the first entry is an XDMF primitive topology
                    key (here 5 for polygon), the second entry the XDMF primitive
                    count value (here 4 because each face is a quad).
                    The remaining four values are the vertex indices.
                  unit: NX_UNITLESS
                  dimensions:
                    rank: 1
                    dim: [[1, 36]]
                  unit: NX_UNITLESS
                  dimensions:
                    rank: 1
                    dim: [[1, 36]]

                number_of_boundaries(NX_POSINT):
                  exists: optional
                  doc: |
                    How many distinct boundaries are distinguished?
                    Most grids discretize a cubic or cuboidal region. In this case
                    six sides can be distinguished, each making an own boundary.
                  unit: NX_UNITLESS
              boundaries(NX_CHAR):
                exists: optional
                doc: |
                  Name of the boundaries. E.g. left, right, front, back, bottom, top,
                  The field must have as many entries as there are number_of_boundaries.
                dimensions:
                  rank: 1
                  dim: [[1, 6]]
              boundary_conditions(NX_INT):
                exists: optional
                doc: |
                  The boundary conditions for each boundary:
                  
                  0 - undefined
                  1 - open
                  2 - periodic
                  3 - mirror
                  4 - von Neumann
                  5 - Dirichlet
                  
                unit: NX_UNITLESS
                dimensions:
                  rank: 1
                  dim: [[1, 6]]
            # ##MK::how to avoid storing it for once in NeXus for H5Web and
            # for XDMF in ParaView ?
            scalar_field_magnitude(NXdata):
              doc: |
                The result of the delocalization based on which subsequent
                iso-surfaces will be computed. In commercial software so far
                there is not a possibility to export such grid.
              # ##MK::math notation
              \@long_name:
                exists: optional
              \@signal:
              \@axes:
              \@xpos_indices:
              \@ypos_indices:
              \@zpos_indices:
              intensity(NX_FLOAT):
                dimensions:
                  rank: 3
                  dim: [[1, n_z], [2, n_y], [3, n_x]]  # silent flip here?
              xpos(NX_FLOAT):
                doc: |
                  Cell center of mass positions along x.
                dimensions:
                  rank: 1
                  dim: [[1, n_x]]
                # ##MK::how to relate back that this x is paraprobe x?
              ypos(NX_FLOAT):
                doc: |
                  Cell center of mass positions along y.
                dimensions:
                  rank: 1
                  dim: [[1, n_y]]
              zpos(NX_FLOAT):
                doc: |
                  Cell center of mass positions along z.
                dimensions:
                  rank: 1
                  dim: [[1, n_z]]
              xdmf_intensity(NX_FLOAT):
                exists: optional
                doc: |
                  Intensity of the field at given point
                unit: NX_ANY
                dimensions:
                  rank: 1
                  dim: [[1, n_xyz]]
              xdmf_xyz(NX_FLOAT):
                exists: optional
                doc: |
                  Center of mass positions of each voxel for
                  rendering the scalar field via XDMF in e.g.
                  Paraview.
                unit: NX_UNITLESS
                dimensions:
                  rank: 2
                  dim: [[1, n_xyz], [2, 3]]
              xdmf_topology(NX_NUMBER):
                exists: optional  # but when xdmf_xyz exists also xdmf_topology has to exist
                doc: |
                  XDMF topology for rendering in combination with
                  xdmf_xyz the scalar field via XDFM in e.g. Paraview.
                unit: NX_UNITLESS
                dimensions:
                  rank: 1
                  dim: [[1, 3*n_xyz]]  # ##MK::better syntax needed
            scalar_field_gradient(NXdata):
              doc: |
                The three-dimensional gradient nabla operator applied to
                scalar_field_magnitude. 
              # ##MK::boundary conditions which type of accuracy
              # ##MK::math notation
              \@signal:
              \@axes:
              # ##MK::vector_indices, # ##MK: 3
              \@xpos_indices:  # ##MK: 2
              \@ypos_indices:  # ##MK: 1
              \@zpos_indices:  # ##MK: 0
              \@long_name:
                exists: optional
              intensity(NX_FLOAT):
                dimensions:
                  rank: 4
                  dim: [[1, n_z], [2, n_y], [3, n_x], [4, 3]]  # silent flip here?
              xpos(NX_FLOAT):
                doc: |
                  Cell center of mass positions along x.
                dimensions:
                  rank: 1
                  dim: [[1, n_x]]
                # ##MK::how to relate back that this x is paraprobe x?
              ypos(NX_FLOAT):
                doc: |
                  Cell center of mass positions along y.
                dimensions:
                  rank: 1
                  dim: [[1, n_y]]
              zpos(NX_FLOAT):
                doc: |
                  Cell center of mass positions along z.
                dimensions:
                  rank: 1
                  dim: [[1, n_z]]
              xdmf_gradient(NX_FLOAT):
                exists: optional
                doc: |
                  The gradient vector.
                unit: NX_ANY
                dimensions:
                  rank: 2
                  dim: [[1, n_xyz], [2, 3]]
              xdmf_xyz(NX_FLOAT):
                exists: optional
                doc: |
                  Center of mass positions of each voxel for
                  rendering the scalar field via XDMF in e.g.
                  Paraview.
                unit: NX_UNITLESS
                dimensions:
                  rank: 2
                  dim: [[1, n_xyz], [2, 3]]
              xdmf_topology(NX_NUMBER):
                exists: optional  # but when xdmf_xyz exists also xdmf_topology has to exist
                doc: |
                  XDMF topology for rendering in combination with
                  xdmf_xyz the scalar field via XDFM in e.g. Paraview.
                unit: NX_UNITLESS
                dimensions:
                  rank: 1
                  dim: [[1, 3*n_xyz]]  # ##MK::better syntax needed
            kernel_size(NX_POSINT):
              doc: |
                Halfwidth of the kernel about the central voxel.
                The shape of the kernel is that of a cuboid
                of extent 2*kernel_extent[i] + 1 in each dimension i.
              unit: NX_DIMENSIONLESS
              #\@units: pixel
              dimensions:
                rank: 1
                dim: [[1, 3]]
            # kernel_type(NX_CHAR):
            #   doc: |
            #     Functional form of the kernel (Ansatz function).
            kernel_sigma(NX_FLOAT):
              doc: |
                Sigma of the kernel in each dimension in the paraprobe
                coordinate_system with i = 0 is x, i = 1 is y, i = 2 is z.
              unit: NX_LENGTH
              dimensions:
                rank: 1
                dim: [[1, 3]]
            kernel_mu(NX_FLOAT): ##MK
              doc: |
                Expectation value of the kernel in each dimension in the paraprobe
                coordinate_system with i = 0 is x, i = 1 is y, i = 2 is z.
              unit: NX_LENGTH
              dimensions:
                rank: 1
                dim: [[1, 3]]
            # ##MK::
          iso_surface(NXisocontour):
            exists: optional
            doc: |
              An iso-surface is the boundary between two regions across which
              the magnitude of a scalar field falls below/exceeds a threshold
              magnitude phi.
              For applications in atom probe microscopy the location and shape
              of such a boundary (set) is typically approximated by
              discretization.
              This yields a complex of not necessarily connected geometric
              primitives. Paraprobe-nanochem approximates this complex with
              a soup of triangles.
            dimensionality(NX_POSINT):
              unit: NX_UNITLESS
            isovalue(NX_NUMBER):
              doc: The threshold or iso-contour value.
              unit: NX_ANY
            marching_cubes(NXcg_marching_cubes):
              doc: |
                Details about the specific marching cubes algorithm
                which was taken to compute the iso-surface.
                The grid is the delocalization grid.
              implementation:
                doc: |
                  Reference to the specific implementation of marching cubes used.
                  The value placed here should be a DOI. If there are no specific
                  DOI or details write not_further_specified, or give at least a
                  free-text description. The program and version used is the
                  specific paraprobe-nanochem.
            triangle_soup(NXcg_triangle_set):
              exists: optional
              doc: |
                The resulting triangle soup computed via marching cubes.
              dimensionality(NX_POSINT):
                unit: NX_UNITLESS
              cardinality(NX_POSINT):
                unit: NX_UNITLESS
              identifier_offset(NX_INT):
                doc: |
                  Integer which specifies the first index to be used for
                  distinguishing triangles. Identifiers are defined either
                  implicitly or explicitly. For implicit indexing the
                  identifiers are defined on the interval
                  [identifier_offset, identifier_offset+c-1].
                unit: NX_UNITLESS
              triangles(NXcg_face_list_data_structure):
                number_of_vertices(NX_POSINT):
                  doc: Number of vertices.
                  unit: NX_UNITLESS
                number_of_faces(NX_POSINT):
                  doc: Number of faces.
                  unit: NX_UNITLESS
                vertex_identifier_offset(NX_INT):
                  doc: |
                    Integer which specifies the first index to be used for distinguishing
                    identifiers for vertices. Identifiers are defined either implicitly
                    or explicitly. For implicit indexing the identifiers are defined on the
                    interval [identifier_offset, identifier_offset+c-1].
                  unit: NX_UNITLESS
                face_identifier_offset(NX_INT):
                  doc: |
                    Integer which specifies the first index to be used for distinguishing
                    identifiers for faces. Identifiers are defined either implicitly
                    or explicitly. For implicit indexing the identifiers are defined on the
                    interval [identifier_offset, identifier_offset+c-1].
                  unit: NX_UNITLESS
                vertices(NX_NUMBER):
                  doc: |
                    Positions of the vertices.
                    
                    Users are encouraged to reduce the vertices to unique set of positions
                    and vertices as this supports a more efficient storage of the geometry data.
                    It is also possible though to store the vertex positions naively in which
                    case vertices_are_unique is likely False.
                    Naively here means that one for example stores each vertex of a triangle
                    mesh even though many vertices are shared between triangles and thus
                    the positions of these vertices do not have to be duplicated.
                  unit: NX_LENGTH
                  dimensions:
                    rank: 2
                    dim: [[1, i], [2, 3]]
                faces(NX_INT):
                  doc: |
                    Array of identifiers from vertices which describe each face.
                    
                    The first entry is the identifier of the start vertex of the first face,
                    followed by the second vertex of the first face, until the last vertex
                    of the first face. Thereafter, the start vertex of the second face, the
                    second vertex of the second face, and so on and so forth.
                    
                    Therefore, summating over the number_of_vertices, allows to extract
                    the vertex identifiers for the i-th face on the following index interval
                    of the faces array: [$\sum_i = 0}^{i = n-1}$, $\sum_{i=0}^{i = n}$].
                  unit: NX_UNITLESS
                  dimensions:
                    rank: 1
                    dim: [[1, j]]
                xdmf_topology(NX_UINT):
                  doc: |
                    A list of as many tuples of XDMF topology key, XDMF number
                    of vertices and a triple of vertex indices specifying each
                    triangle. The total number of entries is n_f_tri * (1+1+3).
                  unit: NX_UNITLESS
                  dimensions:
                    rank: 1
                    dim: [[1, n_f_tri_xdmf]]
                vertex_normal(NXcg_unit_normal_set):
                  exists: optional
                  normals(NX_FLOAT):
                    doc: |
                      Direction of each normal.
                    unit: NX_DIMENSIONLESS
                    dimensions:
                      rank: 2
                      dim: [[1, j], [2, 3]]
                  orientation(NX_UINT):
                    exists: optional
                    doc: |
                      Qualifier how which specifically oriented normal to its
                      primitive each normal represents.
                      
                      * 0 - undefined
                      * 1 - outer
                      * 2 - inner
                      
                    unit: NX_UNITLESS
                    dimensions:
                      rank: 1
                      dim: [[1, j]]
                # edge_normal(NXcg_unit_normal_set):
                #   exists: optional
                face_normal(NXcg_unit_normal_set):
                  exists: optional
                  normals(NX_FLOAT):
                    doc: |
                      Direction of each normal.
                    unit: NX_DIMENSIONLESS
                    dimensions:
                      rank: 2
                      dim: [[1, k], [2, 3]]
                  orientation(NX_UINT):
                    exists: optional
                    doc: |
                      Qualifier how which specifically oriented normal to its
                      primitive each normal represents.
                      
                      * 0 - undefined
                      * 1 - outer
                      * 2 - inner
                      
                    unit: NX_UNITLESS
                    dimensions:
                      rank: 1
                      dim: [[1, k]]
                  gradient_guide_magnitude(NX_FLOAT):
                    doc: |
                      Triangle normals are oriented in the direction of the
                      gradient vector of the local delocalized scalar field.
                      :mathref:`$\sum_{x, y, z} {\nabla{c}_i}^2$`.
                    unit: NX_ANY
                    dimensions:
                      rank: 1
                      dim: [[1, k]]
                  # gradient_guide_quality(NX_FLOAT):
                  #   doc: |
                  #     Triangle normals are oriented in the direction of the
                  #     gradient vector of the local delocalized scalar field.
                  #     Sum of squared values of cross product of triangle normal
                  #     construction.
                  #   unit: NX_ANY
                  #   dimensions:
                  #     rank: 1
                  #     dim: [[1, k]]
                  gradient_guide_projection(NX_FLOAT):
                    doc: |
                      Triangle normals are oriented in the direction of the
                      gradient vector of the local delocalized scalar field.
                      The projection variable here describes the cosine of the
                      angle between the gradient direction and the normal
                      direction vector.
                      This is a descriptor of how parallel the projection is
                      that is especially useful to document those triangles
                      for whose projection is almost perpendicular.
                    unit: NX_ANY
                    dimensions:
                      rank: 1
                      dim: [[1, k]]
                area(NX_NUMBER):
                  exists: optional
                  unit: NX_AREA
                  dimensions:
                    rank: 1
                    dim: [[1, j]]
                edge_length(NX_NUMBER):
                  exists: optional
                  doc: |
                    Array of edge length values. For each triangle the edge length
                    is reported for the edges traversed according to the sequence
                    in which vertices are indexed in triangles.
                  unit: NX_LENGTH
                  dimensions:
                    rank: 2
                    dim: [[1, k], [2, 3]]
                interior_angle(NX_NUMBER):
                  exists: optional
                  doc: |
                    Array of interior angle values. For each triangle the angle
                    is reported for the angle opposite to the edges which are
                    traversed according to the sequence in which vertices
                    are indexed in triangles.
                  unit: NX_ANGLE
                  dimensions:
                    rank: 2
                    dim: [[1, j], [2, 3]]
                center(NX_NUMBER):
                  exists: optional
                  doc: The center of mass of each triangle.
                  unit: NX_LENGTH
                  dimensions:
                    rank: 2
                    dim: [[1, j], [2, 3]]
              volumetric_feature(NXprocess):
                exists: optional
                doc: |
                  Iso-surfaces of arbitrary scalar three-dimensional fields
                  can show a complicated topology. Paraprobe-nanochem can run
                  a DBScan-like clustering algorithm which performs a
                  connectivity analysis on the triangle soup. This yields a
                  set of connected features with their surfaces discretized
                  by triangles. Currently, the tool distinguishes at most
                  three types of features:
                  
                  1. So-called objects, i.e. not necessarily watertight features
                     convex polyhedra
                  2. So-called proxies, i.e. features that were replaced by a
                     proxy mesh and made watertight.
                  3. Remaining triangle surface meshes of arbitrary shape and
                     cardinality.
                  
                  These features can be interpreted as microstructural features.
                  Some of them may be precipitates, some of them may be poles,
                  some of them may be segments of dislocation lines or other
                  crystal defects which are decorated (or not) with solutes.
                  
                  Each type of feature needs to be registered in the feature_type
                  dictionary. Type identifiers (keywords are integer), values
                  are human-readable names like object, proxy, undefined
                triangle_cluster_identifier(NX_UINT):
                  doc: |
                    The identifier which the triangle_soup connectivity analysis
                    returned, which constitutes the first step of the
                    volumetric_feature identification process.
                  unit: NX_UNITLESS
                  dimensions:
                    rank: 1
                    dim: [[1, k]]
                feature_type_dict_keyword(NX_UINT):
                  exists: optional
                  doc: |
                    The array of keywords of feature_type dictionary.
                  unit: NX_UNITLESS
                  dimensions:
                    rank: 1
                    dim: [[1, n_feature_dict]]
                feature_type_dict_value(NX_CHAR):
                  exists: optional
                  doc: |
                    The array of values for each keyword of the
                    feature_type dictionary.
                  dimensions:
                    rank: 1
                    dim: [[1, n_feature_dict]]
                feature_type(NX_UINT):
                  doc: |
                    The array of controlled keywords, need to be from
                    feature_type_dict_keyword, which specify which type
                    each feature triangle cluster belongs to.
                    Keep in mind that not each feature is an object or proxy.
                  unit: NX_ANY
                  dimensions:
                    rank: 1
                    dim: [[1, j]]
                feature_identifier(NX_UINT):
                  doc: |
                    The explicit identifier of features.
                  unit: NX_UNITLESS
                  dimensions:
                    rank: 1
                    dim: [[1, j]]
                # ##MK::a nice example why we need group-overarching symbols
                # a symbol for triangles would not work as the analysis can
                # hold multiple instances of iso_surface each with a different
                # number of triangles and/or features!
                # details about specific features
                objects(NXms_three_d_feature_set):
                  exists: optional
                  doc: |
                    Details for features which are (closed) objects.
                    Identifier have to exist in feature_identifier
                    `:mathcal:$identifier \in feature_identifier$`.
                  # ##MK::constraints!
                  feature_identifier(NX_UINT):
                    unit: NX_UNITLESS
                    dimensions:
                      rank: 1
                      dim: [[1, i]]
                  volume(NX_FLOAT):
                    unit: NX_VOLUME
                    dimensions:
                      rank: 1
                      dim: [[1, i]]
                  obb(NXcg_hexahedron_set):
                    exists: optional
                    doc: |
                      An oriented bounding box (OBB) to each object.
                    size(NX_FLOAT):
                      exists: optional
                      doc: |
                        Edge length of the oriented bounding box from largest
                        to smallest value.
                      unit: NX_LENGTH
                      dimensions:
                        rank: 2
                        dim: [[1, i], [2, 3]]
                    aspect(NX_FLOAT):
                      exists: optional
                      doc: |
                        Oriented bounding box aspect ratio. YX versus ZY.
                      #  ##MK::which is which
                      unit: NX_DIMENSIONLESS
                      dimensions:
                        rank: 2
                        dim: [[1, i], [2, 2]]
                    center(NX_NUMBER):
                      exists: optional
                      doc: |
                        Position of the geometric center, which often is but
                        not necessarily has to be the center_of_mass of the
                        hexahedrally-shaped sample/sample part.
                      unit: NX_LENGTH
                      dimensions:
                        rank: 2
                        dim: [[1, i], [2, 3]]
                    hexahedra(NXcg_face_list_data_structure):
                      # exists: [min, 0, max, 1]
                      doc: |
                        A simple approach to describe the entire set of hexahedra
                        when the main intention is to store the shape of the 
                        hexahedra for visualization.
                      # ##MK::more details needed here
                      vertices(NX_NUMBER):
                        unit: NX_LENGTH
                        dimensions:
                          rank: 2
                          dim: [[1, k], [2, 3]]
                          # ##MK::again we have no effective way to pinpoint the n_rows
                          # ##MK::namely k != i each OBB has eight vertices
                      xdmf_topology(NX_UINT):
                        unit: NX_UNITLESS
                        dimensions:
                          rank: 1
                          dim: [[1, k]]
                      xdmf_feature_identifier(NX_UINT):
                        unit: NX_UNITLESS
                        dimensions:
                          rank: 1
                          dim: [[1, k]]
                  objects_close_to_edge(NXms_three_d_feature_set):
                    exists: optional
                    doc: |
                      Details for all those objects close to edge, i.e. those which
                      have at least one ion which lays closer to a modelled edge
                      of the dataset than threshold.
                    feature_identifier(NX_UINT):
                      unit: NX_UNITLESS
                      dimensions:
                        rank: 1
                        dim: [[1, i]]
                    volume(NX_FLOAT):
                      unit: NX_VOLUME
                      dimensions:
                        rank: 1
                        dim: [[1, i]]
                    composition(NXchemical_composition):
                      exists: optional
                      total(NX_NUMBER):
                        doc: |
                          Total (count) relevant for normalization.
                        unit: NX_UNITLESS
                        dimensions:
                          rank: 1
                          dim: [[1, i]]
                      ION(NXion):
                        exists: [min, 0, max, infty]  # ##MK::should be n_speci or 0 !
                        charge(NX_INT):
                        isotope_vector(NX_UINT):
                        nuclid_list(NX_UINT):
                        count(NX_NUMBER):
                          doc: |
                            Count or weight which, when divided by total,
                            yields the composition of this element, isotope,
                            molecule or ion.
                          unit: NX_UNITLESS
                          dimensions:
                            rank: 1
                            dim: [[1, i]]
                    objectID(NXcg_polyhedron_set):
                      exists: [min, 0, max, infty]  # ##MK::cannot be more than i
                      polyhedron(NXcg_face_list_data_structure):
                        # number_of_vertices(NX_POSINT):
                        # number_of_faces(NX_POSINT):
                        # vertex_identifier_offset(NX_UINT):
                        # face_identifier_offset(NX_UINT):
                        vertices(NX_FLOAT):
                          unit: NX_LENGTH
                          dimensions:
                            rank: 2
                            dim: [[1, n_v], [2, 3]]
                        faces(NX_UINT):
                          unit: NX_UNITLESS
                          dimensions:
                            rank: 2
                            dim: [[1, n_f], [2, 3]]
                        # face_normals(NXcg_unit_normal_set):
                        face_normals(NX_FLOAT):
                          unit: NX_LENGTH
                          dimensions:
                            rank: 2
                            dim: [[1, n_f], [2, 3]]
                        xdmf_topology(NX_UINT):
                          unit: NX_UNITLESS
                          dimensions:
                            rank: 1
                            dim: [[1, k]]  # not k but predictably related to number_of_faces if these are triangles
                        xdmf_feature_identifier(NX_UINT):
                          unit: NX_UNITLESS
                          dimensions:
                            rank: 1
                            dim: [[1, k]]  # not k but predictably related to number_of_faces if these are triangles
                        ion_identifier(NX_UINT):
                          exists: optional
                          doc: |
                            Array of evaporation_identifier / ion_identifier which
                            specify ions laying inside or on the surface of the feature.
                          unit: NX_UNITLESS
                          dimensions:
                            rank: 1
                            dim: [[1, i]]
                  objects_far_from_edge(NXms_three_d_feature_set):
                    exists: optional
                    doc: |
                      Details for all those objects far from edge, i.e. those
                      whose ions lay all at least threshold distant from a
                      modelled edge of the dataset.
                    feature_identifier(NX_UINT):
                      unit: NX_UNITLESS
                      dimensions:
                        rank: 1
                        dim: [[1, i]]
                    volume(NX_FLOAT):
                      unit: NX_VOLUME
                      dimensions:
                        rank: 1
                        dim: [[1, i]]
                    composition(NXchemical_composition):
                      exists: optional
                      total(NX_NUMBER):
                        doc: |
                          Total (count) relevant for normalization.
                        unit: NX_UNITLESS
                        dimensions:
                          rank: 1
                          dim: [[1, i]]
                      ION(NXion):
                        exists: [min, 0, max, infty]  # ##MK::should be n_speci or 0 !
                        charge(NX_INT):
                        isotope_vector(NX_UINT):
                        nuclid_list(NX_UINT):
                        count(NX_NUMBER):
                          doc: |
                            Count or weight which, when divided by total
                            yields the composition of this element, isotope,
                            molecule or ion.
                          unit: NX_UNITLESS
                          dimensions:
                            rank: 1
                            dim: [[1, i]]
                    objectID(NXcg_polyhedron_set):
                      exists: [min, 0, max, infty]  # ##MK::cannot be more than i
                      polyhedron(NXcg_face_list_data_structure):
                        # number_of_vertices(NX_POSINT):
                        # number_of_faces(NX_POSINT):
                        # vertex_identifier_offset(NX_UINT):
                        # face_identifier_offset(NX_UINT):
                        vertices(NX_FLOAT):
                          unit: NX_LENGTH
                          dimensions:
                            rank: 2
                            dim: [[1, n_v], [2, 3]]
                        faces(NX_UINT):
                          unit: NX_UNITLESS
                          dimensions:
                            rank: 2
                            dim: [[1, n_f], [2, 3]]
                        # face_normals(NXcg_unit_normal_set):
                        face_normals(NX_FLOAT):
                          unit: NX_LENGTH
                          dimensions:
                            rank: 2
                            dim: [[1, n_f], [2, 3]]
                        xdmf_topology(NX_UINT):
                          unit: NX_UNITLESS
                          dimensions:
                            rank: 1
                            dim: [[1, k]]  # not k but predictably related to number_of_faces if these are triangles
                        xdmf_feature_identifier(NX_UINT):
                          unit: NX_UNITLESS
                          dimensions:
                            rank: 1
                            dim: [[1, k]]  # not k but predictably related to number_of_faces if these are triangles
                        ion_identifier(NX_UINT):
                          exists: optional
                          doc: |
                            Array of evaporation_identifier / ion_identifier which
                            specify ions laying inside or on the surface of the feature.
                          unit: NX_UNITLESS
                          dimensions:
                            rank: 1
                            dim: [[1, i]]
                # linear_feature_identification(NXprocess):
                # these would be polylines etc
                proxies(NXms_three_d_feature_set):
                  exists: optional
                  doc: |
                    Details for features which are so-called proxies, i.e. objects
                    which have been reconstructed and combinatorially closed with
                    processing their partial triangulated_surface_mesh
                    (hole filling, refinement).
                    Identifier have to exist in feature_identifier
                    `:mathcal:$identifier \in feature_identifier$`.
                  # ##MK::constraints feature_identifier are a subset of the parent!
                  feature_identifier(NX_UINT):
                    unit: NX_UNITLESS
                    dimensions:
                      rank: 1
                      dim: [[1, i]]
                  volume(NX_FLOAT):
                    unit: NX_VOLUME
                    dimensions:
                      rank: 1
                      dim: [[1, i]]
                  # obb ?
                  proxies_close_to_edge(NXms_three_d_feature_set):
                    exists: optional
                    doc: |
                      Details for those proxies close to edge, i.e. those which
                      have at least one ion which lays closer to a modelled edge
                      of the dataset than threshold.
                      Identifier have to exist in feature_identifier
                      `:mathcal:$identifier \in feature_identifier$`.
                    # ##MK::constraints!
                    feature_identifier(NX_UINT):
                      unit: NX_UNITLESS
                      dimensions:
                        rank: 1
                        dim: [[1, i]]
                    volume(NX_FLOAT):
                      unit: NX_VOLUME
                      dimensions:
                        rank: 1
                        dim: [[1, i]]
                    composition(NXchemical_composition):
                      exists: optional
                      total(NX_NUMBER):
                        doc: |
                          Total (count) relevant for normalization.
                        unit: NX_UNITLESS
                        dimensions:
                          rank: 1
                          dim: [[1, i]]
                      ION(NXion):
                        exists: [min, 0, max, infty]  # ##MK::should be n_speci or 0 !
                        # charge(NX_INT):
                        # isotope_vector(NX_UINT):
                        count(NX_NUMBER):
                          doc: |
                            Count or weight which, when divided by total
                            yields the composition of this element, isotope,
                            molecule or ion.
                          unit: NX_UNITLESS
                          dimensions:
                            rank: 1
                            dim: [[1, i]]
                    objectID(NXcg_polyhedron_set):
                      exists: [min, 0, max, infty]
                      polyhedron(NXcg_face_list_data_structure):
                        # number_of_vertices(NX_POSINT):
                        # number_of_faces(NX_POSINT):
                        # vertex_identifier_offset(NX_UINT):
                        # face_identifier_offset(NX_UINT):
                        vertices(NX_FLOAT):
                          unit: NX_LENGTH
                          dimensions:
                            rank: 2
                            dim: [[1, n_v], [2, 3]]
                        faces(NX_UINT):
                          unit: NX_UNITLESS
                          dimensions:
                            rank: 2
                            dim: [[1, n_f], [2, 3]]
                        # face_normals(NXcg_unit_normal_set):
                        face_normals(NX_FLOAT):
                          unit: NX_LENGTH
                          dimensions:
                            rank: 2
                            dim: [[1, n_f], [2, 3]]
                        xdmf_topology(NX_UINT):
                          unit: NX_UNITLESS
                          dimensions:
                            rank: 1
                            dim: [[1, k]]  # not k but predictably related to number_of_faces if these are triangles
                        xdmf_feature_identifier(NX_UINT):
                          unit: NX_UNITLESS
                          dimensions:
                            rank: 1
                            dim: [[1, k]]  # not k but predictably related to number_of_faces if these are triangles
                        ion_identifier(NX_UINT):
                          exists: optional
                          doc: |
                            Array of evaporation_identifier / ion_identifier which
                            specify ions laying inside or on the surface of the feature.
                          unit: NX_UNITLESS
                          dimensions:
                            rank: 1
                            dim: [[1, i]]
                  proxies_far_from_edge(NXms_three_d_feature_set):
                    exists: optional
                    doc: |
                      Details for those proxies far from edge, i.e. those whose
                      ions lay all at least threshold distant from a
                      modelled edge of the dataset.
                    feature_identifier(NX_UINT):
                      unit: NX_UNITLESS
                      dimensions:
                        rank: 1
                        dim: [[1, i]]
                    volume(NX_FLOAT):
                      unit: NX_VOLUME
                      dimensions:
                        rank: 1
                        dim: [[1, i]]
                    composition(NXchemical_composition):
                      exists: optional
                      total(NX_NUMBER):
                        doc: |
                          Total (count) relevant for normalization.
                        unit: NX_UNITLESS
                        dimensions:
                          rank: 1
                          dim: [[1, i]]
                      ION(NXion):
                        exists: [min, 0, max, infty]  # ##MK::should be n_speci or 0 !
                        # charge(NX_INT):
                        # isotope_vector(NX_UINT):
                        count(NX_NUMBER):
                          doc: |
                            Count or weight which, when divided by total
                            yields the composition of this element, isotope,
                            molecule or ion.
                          unit: NX_UNITLESS
                          dimensions:
                            rank: 1
                            dim: [[1, i]]
                    objectID(NXcg_polyhedron_set):
                      exists: [min, 0, max, infty]
                      polyhedron(NXcg_face_list_data_structure):
                        # number_of_vertices(NX_POSINT):
                        # number_of_faces(NX_POSINT):
                        # vertex_identifier_offset(NX_UINT):
                        # face_identifier_offset(NX_UINT):
                        vertices(NX_FLOAT):
                          unit: NX_LENGTH
                          dimensions:
                            rank: 2
                            dim: [[1, n_v], [2, 3]]
                        faces(NX_UINT):
                          unit: NX_UNITLESS
                          dimensions:
                            rank: 2
                            dim: [[1, n_f], [2, 3]]
                        # face_normals(NXcg_unit_normal_set):
                        face_normals(NX_FLOAT):
                          unit: NX_LENGTH
                          dimensions:
                            rank: 2
                            dim: [[1, n_f], [2, 3]]
                        xdmf_topology(NX_UINT):
                          unit: NX_UNITLESS
                          dimensions:
                            rank: 1
                            dim: [[1, k]]  # not k but predictably related to number_of_faces if these are triangles
                        xdmf_feature_identifier(NX_UINT):
                          unit: NX_UNITLESS
                          dimensions:
                            rank: 1
                            dim: [[1, k]]  # not k but predictably related to number_of_faces if these are triangles
                        ion_identifier(NX_UINT):
                          exists: optional
                          doc: |
                            Array of evaporation_identifier / ion_identifier which
                            specify ions laying inside or on the surface of the feature.
                          unit: NX_UNITLESS
                          dimensions:
                            rank: 1
                            dim: [[1, i]]
      interface_modelling(NXprocess):
        exists: optional
        ion_multiplicity(NX_UINT):
          exists: optional
          doc: |
            The multiplicity whereby the ion position is accounted for
            irrespective whether the ion is considered as a decorator
            of the interface or not.
          unit: NX_UNITLESS
          dimensions:
            rank: 1
            dim: [[1, n_ions]]
        decorator_multiplicity(NX_UINT):
          exists: optional
          doc: |
            The multiplicity whereby the ion position is accounted
            for when the ion is consideredone which is a decorator
            of the interface.
          unit: NX_UNITLESS
          dimensions:
            rank: 1
            dim: [[1, n_ions]]
        initial_interface:  # ##MK::(NXcg_plane_set):
          exists: optional
          doc: |
            The equation of the plane that is fitting initially.
        point_normal_form(NX_FLOAT):
          doc: |
            The four parameter ax + by + cz + d = 0 which define the plane.
          unit: NX_LENGTH
          dimensions:
            rank: 1
            dim: [[1, 4]]
        MESH_CURR_PRE_DCOM_STEP(NXcg_triangle_set):
          exists: [min, 0, max, infty]
          doc: |
            The triangle surface mesh representing the interface model.
            Exported at some iteration before the next DCOM step.
          dimensionality(NX_POSINT):
            unit: NX_UNITLESS
          cardinality(NX_POSINT):
            unit: NX_UNITLESS
          identifier_offset(NX_INT):
            unit: NX_UNITLESS
          triangles(NXcg_face_list_data_structure):
            dimensionality(NX_POSINT):
              unit: NX_UNITLESS
            number_of_vertices(NX_POSINT):
              unit: NX_UNITLESS
            number_of_faces(NX_POSINT):
              unit: NX_UNITLESS
            vertex_identifier_offset(NX_INT):
              unit: NX_UNITLESS
            edge_identifier_offset(NX_INT):
              unit: NX_UNITLESS
            face_identifier_offset(NX_INT):
              unit: NX_UNITLESS
            face_identifier(NX_UINT):
              unit: NX_UNITLESS
              dimensions:
                rank: 1
                dim: [[1, j]]
            vertices(NX_NUMBER):
              unit: NX_LENGTH
              dimensions:
                rank: 2
                dim: [[1, i], [2, 3]]
            faces(NX_UINT):
              unit: NX_UNITLESS
              dimensions:
                rank: 2
                dim: [[1, j], [2, 3]]
            xdmf_topology(NX_UINT):
              unit: NX_UNITLESS
              dimensions:
                rank: 1
                dim: [[1, k]]
          # ##MK::vertex_normal(NXcg_unit_normal_set):
          face_normal(NXcg_unit_normal_set):
            dimensionality(NX_POSINT):
              unit: NX_UNITLESS
            cardinality(NX_POSINT):
              unit: NX_UNITLESS
            normals(NX_FLOAT):
              doc: Direction of each normal
              unit: NX_LENGTH
              dimensions:
                rank: 2
                dim: [[1, j], [2, 3]]
            orientation(NX_UINT):
              doc: |
                Qualifier how which specifically oriented normal to its primitive each
                normal represents.
                
                * 0 - undefined
                * 1 - outer
                * 2 - inner
              unit: NX_UNITLESS
              dimensions:
                rank: 1
                dim: [[1, j]]
          vertex_normal(NXcg_unit_normal_set):
            dimensionality(NX_POSINT):
              unit: NX_UNITLESS
            cardinality(NX_POSINT):
              unit: NX_UNITLESS
            normals(NX_FLOAT):
              doc: Direction of each normal
              unit: NX_LENGTH
              dimensions:
                rank: 2
                dim: [[1, j], [2, 3]]
            orientation(NX_UINT):
              doc: |
                Qualifier how which specifically oriented normal to its primitive each
                normal represents.
                
                * 0 - undefined
                * 1 - outer
                * 2 - inner
              unit: NX_UNITLESS
              dimensions:
                rank: 1
                dim: [[1, j]]
          area(NX_NUMBER):
            unit: NX_AREA
            dimensions:
              rank: 1
              dim: [[1, c]]
          edge_length(NX_NUMBER):
            doc: |
              Array of edge length values. For each triangle the edge length is
              reported for the edges traversed according to the sequence
              in which vertices are indexed in triangles.
            unit: NX_LENGTH
            dimensions:
              rank: 2
              dim: [[1, c], [2, 3]]
          interior_angle(NX_NUMBER):
            doc: |
              Array of interior angle values. For each triangle the angle is
              reported for the angle opposite to the edges which are traversed
              according to the sequence in which vertices are indexed in triangles.
            unit: NX_ANGLE
            dimensions:
              rank: 2
              dim: [[1, c], [2, 3]]
        MESH_CURR_POST_DCOM_STEP(NXcg_triangle_set):
          exists: [min, 0, max, infty]
          doc: |
            The triangle surface mesh representing the interface model.
            Exported at some iteration after the next DCOM step.
          dimensionality(NX_POSINT):
            unit: NX_UNITLESS
          cardinality(NX_POSINT):
            unit: NX_UNITLESS
          identifier_offset(NX_INT):
            unit: NX_UNITLESS
          triangles(NXcg_face_list_data_structure):
            dimensionality(NX_POSINT):
              unit: NX_UNITLESS
            number_of_vertices(NX_POSINT):
              unit: NX_UNITLESS
            number_of_faces(NX_POSINT):
              unit: NX_UNITLESS
            vertex_identifier_offset(NX_INT):
              unit: NX_UNITLESS
            face_identifier_offset(NX_INT):
              unit: NX_UNITLESS
            face_identifier(NX_UINT):
              unit: NX_UNITLESS
              dimensions:
                rank: 1
                dim: [[1, j]]
            vertices(NX_NUMBER):
              unit: NX_LENGTH
              dimensions:
                rank: 2
                dim: [[1, i], [2, 3]]
            faces(NX_UINT):
              unit: NX_UNITLESS
              dimensions:
                rank: 2
                dim: [[1, j], [2, 3]]
            xdmf_topology(NX_UINT):
              unit: NX_UNITLESS
              dimensions:
                rank: 1
                dim: [[1, k]]
          # ##MK::vertex_normal(NXcg_unit_normal_set):
          face_normal(NXcg_unit_normal_set):
            dimensionality(NX_POSINT):
              unit: NX_UNITLESS
            cardinality(NX_POSINT):
              unit: NX_UNITLESS
            normals(NX_FLOAT):
              doc: Direction of each normal
              unit: NX_LENGTH
              dimensions:
                rank: 2
                dim: [[1, j], [2, 3]]
            orientation(NX_UINT):
              doc: |
                Qualifier how which specifically oriented normal to its primitive each
                normal represents.
                
                * 0 - undefined
                * 1 - outer
                * 2 - inner
              unit: NX_UNITLESS
              dimensions:
                rank: 1
                dim: [[1, j]]
          vertex_normal(NXcg_unit_normal_set):
            dimensionality(NX_POSINT):
              unit: NX_UNITLESS
            cardinality(NX_POSINT):
              unit: NX_UNITLESS
            normals(NX_FLOAT):
              doc: Direction of each normal
              unit: NX_LENGTH
              dimensions:
                rank: 2
                dim: [[1, j], [2, 3]]
            orientation(NX_UINT):
              doc: |
                Qualifier how which specifically oriented normal to its primitive each
                normal represents.
                
                * 0 - undefined
                * 1 - outer
                * 2 - inner
              unit: NX_UNITLESS
              dimensions:
                rank: 1
                dim: [[1, j]]

          area(NX_NUMBER):
            unit: NX_AREA
            dimensions:
              rank: 1
              dim: [[1, c]]
          edge_length(NX_NUMBER):
            doc: |
              Array of edge length values. For each triangle the edge length is
              reported for the edges traversed according to the sequence
              in which vertices are indexed in triangles.
            unit: NX_LENGTH
            dimensions:
              rank: 2
              dim: [[1, c], [2, 3]]
          interior_angle(NX_NUMBER):
            doc: |
              Array of interior angle values. For each triangle the angle is
              reported for the angle opposite to the edges which are traversed
              according to the sequence in which vertices are indexed in triangles.
            unit: NX_ANGLE
            dimensions:
              rank: 2
              dim: [[1, c], [2, 3]]

      composition_analysis(NXprocess):
        exists: optional
        xdmf_cylinder(NXcg_polyhedron_set):
          doc: |
            The ROIs are defined as cylinders for the computations.
            To visualize these though we discretize them into regular n-gons.
            Using for instance a 360-gon, i.e. a regular n-gon with 360
            edges resolves the lateral surface of each cylinder very finely
            so that they are rendered smoothly in visualization software.
          dimensionality(NX_POSINT):
            unit: NX_UNITLESS
          cardinality(NX_POSINT):
            unit: NX_UNITLESS
          center(NX_NUMBER):
            doc: |
              Position of the geometric center, which often is but not 
              necessarily has to be the center_of_mass of the polyhedra.
            unit: NX_LENGTH
            dimensions:
              rank: 2
              dim: [[1, i], [2, 3]]
          roi_identifier(NX_UINT):
            doc: |
              Integer which specifies the first index to be used for distinguishing
              ROI cylinder. Identifiers are defined explicitly.
            unit: NX_UNITLESS
            dimensions:
              rank: 1
              dim: [[1, i]]
          polyhedra(NXcg_face_list_data_structure):
            exists: [min, 0, max, 1]
          edge_contact(NX_UINT):
            exists: optional
            unit: NX_UNITLESS
            dimensions:
              rank: 1
              dim: [[1, i]]
          number_of_atoms(NX_UINT):
            exists: optional
            doc: |
              The number of atoms in each ROI.
            # ##MK::decomposed?
            unit: NX_UNITLESS
            dimensions:
              rank: 1
              dim: [[1, i]]
          number_of_ions(NX_UINT):
            exists: optional
            doc: |
              The number of ions in each ROI.
            unit: NX_UNITLESS
            dimensions:
              rank: 1
              dim: [[1, i]]
          orientation(NX_FLOAT):
            exists: optional
            doc: |
              The orientation of the ROI defined via a vector which points along
              the cylinder axis and whose length is the height of the cylinder.
            unit: NX_LENGTH
            dimensions:
              rank: 2
              dim: [[1, i], [2, 3]]
          ROI(NXcollection):
            exists: [min, 0, max, infty]
            signed_distance(NX_FLOAT):
              doc: In the direction of the ROI.
            isotope(NX_UINT):
              doc: Hashvalue
          # ##MK::#define MYCHM_DATA_ISRF_TSKS_TSCL_OBJ_ROICYL_ROIID	"RoiCylinderID"
          # ##MK::#define MYCHM_DATA_ISRF_TSKS_TSCL_OBJ_ROICYL_OBJID	"RoiCylinderObjectID"
# ##MK::end of the tool-specific section

    performance(NXcs_profiling):
      exists: recommended
      current_working_directory:
      command_line_call:
        exists: optional
      start_time(NX_DATE_TIME):
        exists: recommended
      end_time(NX_DATE_TIME):
        exists: recommended
      total_elapsed_time(NX_NUMBER):
      number_of_processes(NX_POSINT):
      number_of_threads(NX_POSINT):
      number_of_gpus(NX_POSINT):
      (NXcs_computer):
        exists: recommended
        name:
          exists: recommended
        operating_system:
          \@version:
        uuid:
          exists: optional
        (NXcs_cpu):
          exists: [min, 0, max, infty]
          name:
            exists: optional
          (NXfabrication):
            exists: recommended
            identifier:
              exists: optional
            capabilities:
              exists: optional
        (NXcs_gpu):
          exists: [min, 0, max, infty]
          name:
            exists: optional
          (NXfabrication):
            exists: recommended
            identifier:
              exists: optional
            capabilities:
              exists: optional
        (NXcs_mm_sys):
          exists: [min, 0, max, 1]
          total_physical_memory(NX_NUMBER):
        (NXcs_io_sys):
          exists: [min, 0, max, 1]
          (NXcs_io_obj):
            exists: [min, 1, max, infty]
            technology:
            max_physical_capacity(NX_NUMBER):
            name:
              exists: optional
            (NXfabrication):
              exists: recommended
              identifier:
                exists: optional
              capabilities:
                exists: optional

        (NXcs_profiling_event):
          start_time(NX_DATE_TIME):
            exists: optional
          end_time(NX_DATE_TIME):
            exists: optional
          description:
          elapsed_time(NX_NUMBER):
          number_of_processes(NX_POSINT):
            # exists: recommended
            doc: |
              Specify if it was different from the number_of_processes
              in the NXcs_profiling super class.
          number_of_threads(NX_POSINT):
            # exists: recommended
            doc: |
              Specify if it was different from the number_of_threads
              in the NXcs_profiling super class.
          number_of_gpus(NX_POSINT):
            # exists: recommended
            doc: |
              Specify if it was different from the number_of_threads
              in the NXcs_profiling super class.
          max_virtual_memory_snapshot(NX_NUMBER):
            exists: recommended
          max_resident_memory_snapshot(NX_NUMBER):
            exists: recommended
