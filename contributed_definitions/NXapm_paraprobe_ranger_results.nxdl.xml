<?xml version='1.0' encoding='UTF-8'?>
<?xml-stylesheet type="text/xsl" href="nxdlformat.xsl"?>
<!--
# NeXus - Neutron and X-ray Common Data Format
# 
# Copyright (C) 2014-2024 NeXus International Advisory Committee (NIAC)
# 
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 3 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# For further information, see http://www.nexusformat.org
-->
<definition xmlns="http://definition.nexusformat.org/nxdl/3.1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" category="application" type="group" name="NXapm_paraprobe_ranger_results" extends="NXobject" xsi:schemaLocation="http://definition.nexusformat.org/nxdl/3.1 ../nxdl.xsd">
    <symbols>
        <doc>
             The symbols used in the schema to specify e.g. dimensions of arrays.
        </doc>
        <symbol name="n_ions">
            <doc>
                 The total number of ions in the reconstructed volume.
            </doc>
        </symbol>
    </symbols>
    <doc>
         Application definition for results files of the paraprobe-transcoder tool.
         
         This tool is part of the paraprobe-toolbox. Inspect the base class :ref:`NXapm_paraprobe_tool_results`.
         The purpose and need of the paraprobe-ranger tool is to apply a given set of ranging definitions within
         a certain (possibly complicated) selection of ions (based on their properties or location in the
         reconstructed volume.
    </doc>
    <group type="NXentry" minOccurs="1" maxOccurs="1">
        <attribute name="version" type="NX_CHAR">
            <doc>
                 Version specifier of this application definition.
            </doc>
        </attribute>
        <field name="definition" type="NX_CHAR">
            <doc>
                 NeXus NXDL schema with which this file was written.
            </doc>
            <enumeration>
                <item value="NXapm_paraprobe_ranger_results"/>
            </enumeration>
        </field>
        <group name="apply_existent_ranging" type="NXapm_paraprobe_tool_results" minOccurs="0" maxOccurs="1">
            <doc>
                 Paraprobe-ranger loads the iontypes and evaluates for each
                 ion on which iontype it matches. If it matches on none, the
                 ion is considered of the default unknown type with a 0
                 as its respective value in the iontypes array.
            </doc>
            <!--#MK::number_of_ion_types(NX_POSINT):-->
            <field name="maximum_number_of_atoms_per_molecular_ion" type="NX_POSINT" units="NX_UNITLESS">
                <doc>
                     The length of the isotope_vector used to describe molecular ions.
                </doc>
            </field>
            <group type="NXion" minOccurs="1" maxOccurs="256">
                <field name="isotope_vector" type="NX_UINT"/>
                <field name="nuclid_list" type="NX_UINT" recommended="true"/>
                <field name="charge_state" type="NX_INT"/>
                <field name="mass_to_charge_range" type="NX_FLOAT"/>
            </group>
            <field name="iontypes" type="NX_UINT" units="NX_UNITLESS">
                <doc>
                     The iontype (identifier) for each ion that was best matching, stored
                     in the order of the evaporation sequence ID. The here computed iontypes
                     do not take into account the charge state of the ion which is
                     equivalent to interpreting a RNG and RRNG range files for each
                     ion in such a way that only the elements of which a (molecular) ion
                     was built are considered.
                </doc>
                <dimensions rank="1">
                    <dim index="1" value="n_ions"/>
                </dimensions>
            </field>
            <group name="window" type="NXcs_filter_boolean_mask">
                <doc>
                     A bitmask which identifies exactly all those ions ranged
                     irrespective of the assigned type. This information
                     can be used to numerically recover the ROI selection.
                </doc>
                <field name="number_of_ions" type="NX_UINT" units="NX_UNITLESS">
                    <doc>
                         Number of ions covered by the mask.
                         The mask value for most may be 0.
                    </doc>
                </field>
                <field name="bitdepth" type="NX_UINT" units="NX_UNITLESS">
                    <doc>
                         Number of bits assumed matching on a default datatype.
                    </doc>
                </field>
                <field name="mask" type="NX_UINT" units="NX_UNITLESS">
                    <doc>
                         The unsigned integer array representing the content of the mask.
                         If padding is used the padded bits are set to 0. The mask is for
                         convenience always as large as the entire dataset as it will
                         be stored compressed anyway. The convenience feature with this
                         is that then the mask can be decoded with numpy and mirrored
                         against the evaporation_id array and one immediately can filter
                         out all points that were used by the paraprobe.
                         The length of the array adds to the next unsigned integer
                         if the number of ions in the dataset is not an integer
                         multiple of the bitdepth.
                    </doc>
                    <dimensions rank="1">
                        <dim index="1" value="i"/>
                    </dimensions>
                </field>
            </group>
        </group>
        <group type="NXprogram"/>
        <group name="profiling" type="NXcs_profiling">
            <field name="start_time" type="NX_DATE_TIME"/>
            <field name="end_time" type="NX_DATE_TIME"/>
            <field name="status" type="NX_CHAR"/>
            <field name="results_path" type="NX_CHAR" recommended="true"/>
            <field name="current_working_directory" type="NX_CHAR"/>
            <field name="total_elapsed_time" type="NX_NUMBER"/>
            <field name="number_of_processes" type="NX_POSINT"/>
            <field name="number_of_threads" type="NX_POSINT"/>
            <field name="number_of_gpus" type="NX_POSINT"/>
        </group>
        <group type="NXuser" minOccurs="0" maxOccurs="unbounded">
            <field name="name" type="NX_CHAR"/>
        </group>
        <group type="NXcoordinate_system_set">
            <group name="paraprobe" type="NXcoordinate_system">
                <field name="type" type="NX_CHAR"/>
                <field name="handedness" type="NX_CHAR"/>
                <field name="x" type="NX_NUMBER" units="NX_LENGTH">
                    <dimensions rank="1">
                        <dim index="1" value="3"/>
                    </dimensions>
                </field>
                <field name="y" type="NX_NUMBER" units="NX_LENGTH">
                    <dimensions rank="1">
                        <dim index="1" value="3"/>
                    </dimensions>
                </field>
                <field name="z" type="NX_NUMBER" units="NX_LENGTH">
                    <dimensions rank="1">
                        <dim index="1" value="3"/>
                    </dimensions>
                </field>
            </group>
        </group>
    </group>
    <!--molecular_ion_search(NXprocess):
exists: ['min', '0', 'max', '1']
doc: |
Paraprobe-ranger performs a combinatorial search over
all possible or a reduced set of nuclids to identify
into which ions these can be composed.
isotope_vector_matrix(NX_UINT):
unit: NX_UNITLESS
doc: |
The main result is the list of molecular ions, here formatted
according to the definitions of a set of isotope_vectors
as detailed in :ref:`NXion`.
dimensions:
rank: 2
dim: [[1, i], [2, 32]]
mass_to_charge_state_ratio(NX_FLOAT):
unit: NX_ANY
doc: |
The mass-to-charge-state ratio of each molecular ion
without considering relativistic or quantum effects.
dimensions:
rank: 1
dim: [[1, i]]
mass(NX_FLOAT):
exists: optional
unit: NX_ANY
doc: |
The mass of each molecular ion without
considering relativistic or quantum effects.-->
    <!--# \@units: amu
dimensions:
rank: 1
dim: [[1, i]]
charge_state(NX_UINT):
unit: NX_CHARGE
doc: |
The charge_state of each molecular ion.
dimensions:
rank: 1
dim: [[1, i]]
natural_abundance_product(NX_FLOAT):
exists: optional
unit: NX_DIMENSIONLESS
doc: |
The product of the natural abundance of the isotopes building
each molecular ion. Further details are available in
:ref:`NXapm_paraprobe_config_ranger`.
dimensions:
rank: 1
dim: [[1, i]]
composition_product(NX_FLOAT):
exists: optional
unit: NX_DIMENSIONLESS
doc: |
The product of the natural abundance of the isotopes building
each molecular ion. Further details are available in
:ref:`NXapm_paraprobe_config_ranger`.
dimensions:
rank: 1
dim: [[1, i]]
number_of_disjoint_nuclids(NX_POSINT):
exists: optional
unit: NX_UNITLESS
doc: |
The number of disjoint nuclids for each molecular ion.
dimensions:
rank: 1
dim: [[1, i]]
number_of_nuclids(NX_POSINT):
exists: optional
unit: NX_UNITLESS
doc: |
The number of nuclids for each molecular ion.
dimensions:
rank: 1
dim: [[1, i]]
check_existent_ranging(NXprocess):
exists: ['min', '0', 'max', '1']
doc: |
Paraprobe-ranger loads iontypes and evaluates for each ion on which
iontype it matches. If it matches on none, the ion is considered of
the default unknown type with a 0 as its respective value in the
iontypes array. In contrast to use_existent_ranging this process
does neither needs measured ion position nor mass-to-charge-state
ratio values.-->
    <!--##MK::number_of_ion_types(NX_POSINT):
maximum_number_of_atoms_per_molecular_ion(NX_POSINT):
unit: NX_UNITLESS
doc: |
The length of the isotope_vector used to describe molecular ions.
charged_ION(NXion):
exists: ['min', '1', 'max', '256']
isotope_vector(NX_UINT):
nuclid_list(NX_UINT):
exists: recommended
charge_state(NX_INT):
mass_to_charge_range(NX_FLOAT):-->
</definition>
