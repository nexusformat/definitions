<?xml version='1.0' encoding='UTF-8'?>
<?xml-stylesheet type="text/xsl" href="nxdlformat.xsl"?>
<!--
# NeXus - Neutron and X-ray Common Data Format
#
# Copyright (C) 2014-2024 NeXus International Advisory Committee (NIAC)
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 3 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# For further information, see http://www.nexusformat.org
-->
<definition xmlns="http://definition.nexusformat.org/nxdl/3.1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" category="application" type="group" name="NXapm_composition_space_results" extends="NXobject" xsi:schemaLocation="http://definition.nexusformat.org/nxdl/3.1 ../nxdl.xsd">
    <symbols>
        <doc>
             The symbols used in the schema to specify e.g. dimensions of arrays.
        </doc>
        <symbol name="n_voxel">
            <doc>
                 Number of voxel of discretized domain for analyzed part of the dataset.
            </doc>
        </symbol>
        <symbol name="d">
            <doc>
                 The dimensionality of the grid.
            </doc>
        </symbol>
        <symbol name="c">
            <doc>
                 The cardinality or total number of cells/grid points.
            </doc>
        </symbol>
        <symbol name="n_clst_dict">
            <doc>
                 Number of terms in the composition clustering dictionary
            </doc>
        </symbol>
        <symbol name="n_spat_dict">
            <doc>
                 Number of terms in the position clustering dictionary
            </doc>
        </symbol>
    </symbols>
    <doc>
         Results of a run with Alaukik Saxena's composition space tool.
         
         This is an initial draft application definition for the common NFDI-MatWerk,
         FAIRmat infrastructure use case IUC09 how to improve the organization and
         results storage of the composition space tool and make these data at the
         same time directly understandable for research data management systems
         like NOMAD Oasis.
    </doc>
    <!--by default for appdefs the value of the exists keyword is required unless it is explicitly specified differently-->
    <group type="NXentry" minOccurs="1" maxOccurs="1">
        <field name="definition" type="NX_CHAR">
            <attribute name="version" type="NX_CHAR"/>
            <enumeration>
                <item value="NXapm_composition_space_results"/>
            </enumeration>
        </field>
        <!--can be used for the name of the tool and version but also
for if desired all the dependencies and libraries-->
        <group type="NXprogram" minOccurs="1" maxOccurs="unbounded">
            <field name="program" type="NX_CHAR">
                <attribute name="version" type="NX_CHAR"/>
            </field>
        </group>
        <field name="job_pyiron_identifier" type="NX_CHAR" recommended="true">
            <doc>
                 TBD, maybe how to link between pyiron state tracking and app state tracking.
            </doc>
        </field>
        <field name="description" type="NX_CHAR" optional="true">
            <doc>
                 Disencouraged place for free-text for e.g. comments.
            </doc>
        </field>
        <field name="start_time" type="NX_DATE_TIME">
            <doc>
                 ISO 8601 formatted time code with local time zone offset to UTC
                 information included when the analysis behind this results file
                 was started, i.e. when composition space tool was started as a process.
            </doc>
        </field>
        <field name="end_time" type="NX_DATE_TIME">
            <doc>
                 ISO 8601 formatted time code with local time zone offset to UTC
                 information included when the analysis behind this results file
                 were completed and composition space tool exited as a process.
            </doc>
        </field>
        <!--config-->
        <group name="config" type="NXserialized">
            <doc>
                 The path and name of the config file that was used for this analysis.
                 TBD, this can be e.g. Alaukik's YAML file for composition space.
            </doc>
            <field name="type" type="NX_CHAR"/>
            <field name="path" type="NX_CHAR"/>
            <field name="algorithm" type="NX_CHAR"/>
            <field name="checksum" type="NX_CHAR"/>
        </group>
        <group name="reconstruction" type="NXserialized">
            <doc>
                 Details about the file (technology partner or community format)
                 from which reconstructed ion positions were loaded.
            </doc>
            <field name="type" type="NX_CHAR"/>
            <field name="path" type="NX_CHAR"/>
            <field name="algorithm" type="NX_CHAR"/>
            <field name="checksum" type="NX_CHAR"/>
        </group>
        <group name="ranging" type="NXserialized">
            <doc>
                 Details about the file (technology partner or community format)
                 from which ranging definitions were loaded which detail how to
                 map mass-to-charge-state ratios on iontypes.
            </doc>
            <field name="type" type="NX_CHAR"/>
            <field name="path" type="NX_CHAR"/>
            <field name="algorithm" type="NX_CHAR"/>
            <field name="checksum" type="NX_CHAR"/>
        </group>
        <!--results-->
        <field name="results_path" type="NX_CHAR" optional="true">
            <doc>
                 Path to the directory where the tool should store NeXus/HDF5 results
                 of this analysis. If not specified results will be stored in the
                 current working directory.
            </doc>
        </field>
        <field name="status" type="NX_CHAR">
            <doc>
                 A statement whether the executable managed to process the analysis
                 or failed prematurely. This status is written to the results file after the
                 end_time at which point the executable must not compute any analysis.
                 Only when this status message is present and shows `success`, the
                 user should consider the results. In all other cases it might be
                 that the executable has terminated prematurely or another error
                 occurred.
            </doc>
            <enumeration>
                <item value="success"/>
                <item value="failure"/>
            </enumeration>
        </field>
        <group type="NXuser" recommended="true">
            <doc>
                 If used, contact information and eventually details
                 of at least the person who performed this analysis.
            </doc>
            <field name="name" type="NX_CHAR" recommended="true"/>
            <field name="affiliation" type="NX_CHAR" optional="true"/>
            <group type="NXidentifier" optional="true"/>
            <field name="role" type="NX_CHAR" optional="true"/>
        </group>
        <group type="NXcoordinate_system_set">
            <doc>
                 Details about coordinate systems (reference frames) used. In atom probe several coordinate
                 systems have to be distinguished. Names of instances of such :ref:`NXcoordinate_system`
                 should be documented explicitly and doing so by picking from the
                 following controlled set of names:
                 
                 * composition_space
                 * lab
                 * specimen
                 * laser
                 * instrument
                 * detector
                 * recon
                 
                 The aim of this convention is to support users with contextualizing which reference
                 frame each instance (coordinate system) is. If needed, instances of :ref:`NXtransformations`
                 are used to detail the explicit affine transformations whereby one can convert
                 representations between different reference frames.
                 Inspect :ref:`NXtransformations` for further details.
            </doc>
        </group>
        <group type="NXcoordinate_system">
            <group type="NXtransformations"/>
        </group>
        <!--add further fields coming from using the charge state recovery
workflow from the ifes_apt_tc_data_modeling library-->
        <group name="voxelization" type="NXprocess">
            <field name="sequence_index" type="NX_POSINT">
                <enumeration>
                    <item value="1"/>
                </enumeration>
            </field>
            <!--specify the grid your using and for each ion in which cell i.e. voxel it is
one could also have a more sophisticated data model where there is some
fuzziness i.e. if an ML/AI model returns multiple values or a probability
how likely an ion is in which voxel, for this
inspect the example of the NXem_ebsd application definition-->
            <group type="NXcg_grid">
                <field name="dimensionality" type="NX_POSINT" units="NX_UNITLESS">
                    <enumeration>
                        <item value="1"/>
                        <item value="2"/>
                        <item value="3"/>
                    </enumeration>
                </field>
                <field name="cardinality" type="NX_POSINT" units="NX_UNITLESS"/>
                <!--default behaviour, if no coordinate system defined, unclear
if one coordinate system is defined the origin is defined in this cs-->
                <field name="origin" type="NX_NUMBER" units="NX_LENGTH">
                    <dimensions rank="1">
                        <dim index="1" value="d"/>
                    </dimensions>
                </field>
                <field name="symmetry">
                    <enumeration>
                        <item value="cubic"/>
                    </enumeration>
                </field>
                <field name="cell_dimensions" type="NX_NUMBER" units="NX_LENGTH">
                    <dimensions rank="1">
                        <dim index="1" value="d"/>
                    </dimensions>
                </field>
                <field name="extent" type="NX_POSINT" units="NX_UNITLESS">
                    <dimensions rank="1">
                        <dim index="1" value="d"/>
                    </dimensions>
                </field>
                <group type="NXtransformations" recommended="true">
                    <doc>
                         Reference to or definition of a coordinate system with
                         which the positions and directions are interpretable.
                    </doc>
                </group>
                <field name="identifier_offset" type="NX_INT" units="NX_UNITLESS">
                    <doc>
                         
                    </doc>
                </field>
                <field name="position" type="NX_NUMBER" units="NX_LENGTH">
                    <doc>
                         Position of each cell in Euclidean space.
                    </doc>
                    <dimensions rank="2">
                        <dim index="1" value="c"/>
                        <dim index="2" value="d"/>
                    </dimensions>
                </field>
                <field name="coordinate" type="NX_INT" optional="true" units="NX_DIMENSIONLESS">
                    <dimensions rank="2">
                        <dim index="1" value="c"/>
                        <dim index="2" value="d"/>
                    </dimensions>
                </field>
                <!--bounding box if needed-->
                <field name="voxel_identifier" type="NX_UINT" units="NX_UNITLESS">
                    <doc>
                         For each ion, the identifier of the voxel in which the ion is located.
                    </doc>
                    <dimensions rank="1">
                        <dim index="1" value="n_ions"/>
                    </dimensions>
                </field>
            </group>
            <group type="NXion" minOccurs="0" maxOccurs="unbounded">
                <field name="name"/>
                <field name="composition" type="NX_FLOAT">
                    <dimensions rank="1">
                        <dim index="1" value="n_voxel"/>
                    </dimensions>
                </field>
            </group>
        </group>
        <group name="clustering_composition_space" type="NXprocess">
            <doc>
                 In Alaukik's tool the GMM step.
            </doc>
            <field name="sequence_index" type="NX_POSINT">
                <enumeration>
                    <item value="2"/>
                </enumeration>
            </field>
            <field name="cluster_dict_keyword">
                <doc>
                     The keywords of the dictionary of distinguished compositionally-
                     defined cluster, e.g. the phases. Examples for keywords could be
                     phase1, phase2, and so one and so forth.
                </doc>
                <dimensions rank="1">
                    <dim index="1" value="n_clst_dict"/>
                </dimensions>
            </field>
            <field name="cluster_dict_value" type="NX_UINT" units="NX_UNITLESS">
                <doc>
                     Resolves for each keyword in cluster_dict which integer is used to
                     label something that it belongs or is assumed to represent this
                     cluster.
                </doc>
                <dimensions rank="1">
                    <dim index="1" value="n_clst_dict"/>
                </dimensions>
            </field>
            <!--again for fuzzy or probabilistic multi solution approaches see NXem_ebsd-->
            <field name="cluster_identifier" type="NX_UINT" units="NX_UNITLESS">
                <doc>
                     For example if the voxel grid is used to report that there
                     are voxels which are assumed to represent volume of either phase1
                     or phase2, the cluster_dict_keyword would be a list with two names
                     phase1 and phase2, respectively. The cluster_dict_value would be a
                     list of e.g. integers 1 and 2. These could be used to build an
                     array with as many entries as there are voxel and store in this array
                     the respective value to encode which phase is assumed for each voxel.
                </doc>
                <dimensions rank="1">
                    <dim index="1" value="n_voxel"/>
                </dimensions>
            </field>
        </group>
        <!--use the fact that with e.g. XDMF one can on-the-fly reinterpret
a 1d array to represent an explicit 3d grid
default plots would be nice could directly be integrated in the results file-->
        <group name="clustering_real_space" type="NXprocess">
            <doc>
                 In Alaukik's tool the DBScan step after the GMM step.
            </doc>
            <field name="sequence_index" type="NX_POSINT">
                <enumeration>
                    <item value="3"/>
                </enumeration>
            </field>
            <field name="cluster_dict_keyword">
                <doc>
                     The keywords of the dictionary of distinguished spatially-contiguous
                     clusters. Examples for keywords could be precipitate1, precipitate2,
                     and so one and so forth.
                </doc>
                <dimensions rank="1">
                    <dim index="1" value="n_spat_dict"/>
                </dimensions>
            </field>
            <field name="cluster_dict_value" type="NX_UINT" units="NX_UNITLESS">
                <doc>
                     Resolves for each keyword in cluster_dict which integer is used to
                     label something that it belongs or is assumed to represent this
                     cluster.
                </doc>
                <dimensions rank="1">
                    <dim index="1" value="n_spat_dict"/>
                </dimensions>
            </field>
            <!--again for fuzzy or probabilistic multi solution approaches see NXem_ebsd-->
            <field name="cluster_identifier" type="NX_UINT" units="NX_UNITLESS">
                <doc>
                     For example if the voxel grid is used to report that there
                     are voxels which are assumed to represent volume of certain precipitates,
                     say we found ten precipitates and consider the rest as matrix.
                     We could make a list of say matrix, precipitate1, precipitate2, ...,
                     precipitate10. With cluster_dict_value then running from 0 to 10,
                     i.e. matrix is flagged special as 0 and the remaining particles
                     are indexed conveniently as 1, 2, ..., 10 like end users expect.
                </doc>
                <dimensions rank="1">
                    <dim index="1" value="n_voxel"/>
                </dimensions>
            </field>
        </group>
        <!--use the fact that with e.g. XDMF one can on-the-fly reinterpret
a 1d array to represent an explicit 3d grid
then the entire visualization just needs a smart XDMF file with
one section with the coordinates of the voxel center of masses
one section with the voxel identifier
one section with the "phase" identifier referring to the clustering_composition_space NXprocess group
one section with the "precipitate" identifier referring to the clustering_real_space NXprocess group
technically one should get rid of the unnecessary chunks
instead define an (nx, ny, nz) C-style array which whose data space
is reserved by the h5py library upon first call and then (if desired)
filled incrementally
the array should be chunked not with an auto-chunking but with a nx, ny, >=1 chunking
which will make visualization of nx, ny slices naturally fast, making the z-dimension
chunking as fast as large as possible (needs compromise to remain within chunk cache size)
will also make the orthogonal section a good compromise fast
data should be gzip, level 1 compressed and all the redundant parts of the current
output will collapse substantially-->
        <group name="performance" type="NXcs_profiling">
            <field name="current_working_directory"/>
            <field name="command_line_call" optional="true"/>
            <field name="start_time" type="NX_DATE_TIME" recommended="true"/>
            <field name="end_time" type="NX_DATE_TIME" recommended="true"/>
            <field name="total_elapsed_time" type="NX_NUMBER"/>
            <field name="number_of_processes" type="NX_POSINT"/>
            <field name="number_of_threads" type="NX_POSINT"/>
            <field name="number_of_gpus" type="NX_POSINT"/>
            <group type="NXcs_computer" recommended="true">
                <field name="name" recommended="true"/>
                <field name="operating_system">
                    <attribute name="version"/>
                </field>
                <field name="uuid" optional="true"/>
                <group type="NXcs_cpu" minOccurs="0" maxOccurs="unbounded">
                    <field name="name" optional="true"/>
                    <group type="NXfabrication" recommended="true">
                        <field name="identifier" optional="true"/>
                        <field name="capabilities" optional="true"/>
                    </group>
                </group>
                <group type="NXcs_gpu" minOccurs="0" maxOccurs="unbounded">
                    <field name="name" optional="true"/>
                    <group type="NXfabrication" recommended="true">
                        <field name="identifier" optional="true"/>
                        <field name="capabilities" optional="true"/>
                    </group>
                </group>
                <group type="NXcs_mm_sys" minOccurs="0" maxOccurs="1">
                    <field name="total_physical_memory" type="NX_NUMBER"/>
                </group>
                <group type="NXcs_io_sys" minOccurs="0" maxOccurs="1">
                    <group type="NXcs_io_obj" minOccurs="1" maxOccurs="unbounded">
                        <field name="technology"/>
                        <field name="max_physical_capacity" type="NX_NUMBER"/>
                        <field name="name" optional="true"/>
                        <group type="NXfabrication" recommended="true">
                            <field name="identifier" optional="true"/>
                            <field name="capabilities" optional="true"/>
                        </group>
                    </group>
                </group>
                <group type="NXcs_profiling_event">
                    <field name="start_time" type="NX_DATE_TIME" optional="true"/>
                    <field name="end_time" type="NX_DATE_TIME" optional="true"/>
                    <field name="description"/>
                    <field name="elapsed_time" type="NX_NUMBER"/>
                    <field name="number_of_processes" type="NX_POSINT">
                        <!--
exists: recommended
-->
                        <doc>
                             Specify if it was different from the number_of_processes
                             in the NXcs_profiling super class.
                        </doc>
                    </field>
                    <field name="number_of_threads" type="NX_POSINT">
                        <!--
exists: recommended
-->
                        <doc>
                             Specify if it was different from the number_of_threads
                             in the NXcs_profiling super class.
                        </doc>
                    </field>
                    <field name="number_of_gpus" type="NX_POSINT">
                        <!--
exists: recommended
-->
                        <doc>
                             Specify if it was different from the number_of_threads
                             in the NXcs_profiling super class.
                        </doc>
                    </field>
                    <field name="max_virtual_memory_snapshot" type="NX_NUMBER" recommended="true"/>
                    <field name="max_resident_memory_snapshot" type="NX_NUMBER" recommended="true"/>
                </group>
            </group>
        </group>
    </group>
</definition>
