<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="nxdlformat.xsl"?>
<!--
# NeXus - Neutron and X-ray Common Data Format
# 
# Copyright (C) 2014-2022 NeXus International Advisory Committee (NIAC)
# 
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 3 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# For further information, see http://www.nexusformat.org
-->
<definition xmlns="http://definition.nexusformat.org/nxdl/3.1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" category="application" name="NXapm_paraprobe_config_nanochem" extends="NXobject" type="group" xsi:schemaLocation="http://definition.nexusformat.org/nxdl/3.1 ../nxdl.xsd">
    <symbols>
        <doc>
             The symbols used in the schema to specify e.g. dimensions of arrays.
        </doc>
        <symbol name="n_ityp_deloc_cand">
            <doc>
                 How many iontypes does the delocalization filter specify.
            </doc>
        </symbol>
        <symbol name="n_control_pts">
            <doc>
                 How many disjoint control points are defined.
            </doc>
        </symbol>
        <symbol name="n_fct_filter_cand">
            <doc>
                 How many iontypes does the interface meshing iontype filter specify.
            </doc>
        </symbol>
        <symbol name="n_fct_iterations">
            <doc>
                 How many DCOM iterations.
            </doc>
        </symbol>
        <symbol name="n_ivec">
            <doc>
                 Maximum number of atoms per molecular ion.
            </doc>
        </symbol>
    </symbols>
    <doc>
         Configuration of a paraprobe-nanochem tool run in atom probe microscopy.
    </doc>
    <group type="NXentry">
        <attribute name="version">
            <doc>
                 Version specifier of this application definition.
            </doc>
        </attribute>
        <field name="definition">
            <doc>
                 Official NeXus NXDL schema with which this file was written.
            </doc>
            <enumeration>
                <item value="NXapm_paraprobe_config_nanochem"/>
            </enumeration>
        </field>
        <field name="program">
            <doc>
                 Given name of the program/software/tool with which this NeXus
                 (configuration) file was generated.
            </doc>
            <attribute name="version">
                <doc>
                     Ideally program version plus build number, or commit hash or description
                     of ever persistent resources where the source code of the program and
                     build instructions can be found so that the program can be configured
                     ideally in such a manner that the result of this computational process
                     is recreatable in the same deterministic manner.
                </doc>
            </attribute>
        </field>
        <field name="analysis_identifier">
            <doc>
                 Ideally, a (globally persistent) unique identifier for referring
                 to this analysis.
            </doc>
        </field>
        <field name="analysis_description" optional="true">
            <doc>
                 Possibility for leaving a free-text description about this analysis.
            </doc>
        </field>
        <field name="results_path" optional="true">
            <doc>
                 Path to the directory where the tool should store NeXus/HDF5 results
                 of this analysis. If not specified results will be stored in the
                 current working directory.
            </doc>
        </field>
        <field name="time_stamp" type="NX_DATE_TIME">
            <doc>
                 ISO 8601 formatted time code with local time zone offset to
                 UTC information included when this configuration file was created.
            </doc>
        </field>
        <field name="number_of_processes" type="NX_UINT" units="NX_UNITLESS">
            <doc>
                 How many individual analyses should the tool execute as part of the analysis.
            </doc>
        </field>
        <group type="NXprocess">
            <group name="dataset" type="NXapm_input_reconstruction">
                <field name="filename">
                    <attribute name="version"/>
                </field>
                <field name="dataset_name_reconstruction"/>
                <field name="dataset_name_mass_to_charge"/>
            </group>
            <group name="iontypes" type="NXapm_input_ranging">
                <field name="filename">
                    <attribute name="version"/>
                </field>
                <field name="group_name_iontypes"/>
            </group>
            <group name="spatial_filter" type="NXspatial_filter" optional="true">
                <field name="windowing_method"/>
                <group type="NXcg_ellipsoid_set" optional="true">
                    <field name="dimensionality" type="NX_POSINT"/>
                    <field name="cardinality" type="NX_POSINT"/>
                    <field name="identifier_offset" type="NX_INT"/>
                    <field name="center" type="NX_NUMBER"/>
                    <field name="half_axes_radii" type="NX_NUMBER"/>
                    <field name="orientation" type="NX_NUMBER"/>
                </group>
                <group type="NXcg_cylinder_set" optional="true">
                    <field name="dimensionality" type="NX_POSINT"/>
                    <field name="cardinality" type="NX_POSINT"/>
                    <field name="identifier_offset" type="NX_INT"/>
                    <field name="center" type="NX_NUMBER"/>
                    <field name="height" type="NX_NUMBER"/>
                    <field name="radii" type="NX_NUMBER"/>
                </group>
                <group type="NXcg_hexahedron_set" optional="true">
                    <field name="dimensionality" type="NX_POSINT"/>
                    <field name="cardinality" type="NX_POSINT"/>
                    <field name="identifier_offset" type="NX_INT"/>
                    <group name="hexahedra" type="NXcg_face_list_data_structure"/>
                </group>
                <group type="NXcs_filter_boolean_mask" optional="true">
                    <field name="number_of_objects" type="NX_UINT"/>
                    <field name="bitdepth" type="NX_UINT"/>
                    <field name="mask" type="NX_UINT"/>
                    <field name="identifier" type="NX_UINT"/>
                </group>
            </group>
            <group name="evaporation_id_filter" type="NXsubsampling_filter" optional="true"/>
            <group name="iontype_filter" type="NXmatch_filter" optional="true">
                <field name="method"/>
                <field name="match" type="NX_NUMBER"/>
            </group>
            <group name="hit_multiplicity_filter" type="NXmatch_filter" optional="true"/>
            <group name="edge_of_the_dataset" type="NXprocess">
                <doc>
                     The tool enables to inject a previously computed triangle soup or
                     triangulated surface mesh representing a model (of the surface) of
                     the edge of the dataset. This model can be used to detect and control
                     various sources of bias in the analyses.
                </doc>
                <!--NEW ISSUE: exists: optional-->
                <field name="filename">
                    <doc>
                         Name of the HDF5 file which contains vertex coordinates and facet
                         indices to describe the desired set of triangles which represents
                         the edge of the dataset.
                    </doc>
                    <attribute name="version">
                        <doc>
                             Version identifier of the file such as a secure hash which documents
                             the binary state of the file to add an additional layer of
                             reproducibility from which file specifically contains these data.
                        </doc>
                    </attribute>
                </field>
                <field name="dataset_name_vertices">
                    <doc>
                         Absolute path to the HDF5 dataset in the respectively specified HDF5
                         file under filename which details the array of vertex positions.
                    </doc>
                </field>
                <field name="dataset_name_facet_indices">
                    <doc>
                         Absolute path to the HDF5 dataset in the respective specified HDF5
                         file under filename which details the array of facet indices.
                    </doc>
                </field>
            </group>
            <group name="ion_to_edge_distances" type="NXprocess" optional="true">
                <doc>
                     The tool enables to inject precomputed distance information for each
                     point/ion which can be used for further post-processing and analysis.
                </doc>
                <!--NEW ISSUE: is this optional?-->
                <field name="filename">
                    <doc>
                         Name of an HDF5 file which contains the ion distances.
                    </doc>
                    <attribute name="version">
                        <doc>
                             Version identifier of the file such as a secure hash which documents
                             the binary state of the file to add an additional layer of
                             reproducibility from which file specifically contains these data.
                        </doc>
                    </attribute>
                </field>
                <field name="dataset_name">
                    <doc>
                         Absolute HDF5 path to the dataset with distance values for each ion.
                    </doc>
                </field>
            </group>
            <!--number_of_delocalizations(NX_UINT):
  doc: |
    For now a support field for the tool to identify how many individual
    delocalization analyses for the above-mentioned dataset and supplementary
    files are executed as part of the high-throughput analysis.
  unit: NX_UNITLESS-->
            <!--NEW ISSUE delocalization is all lower case meaning you cannot have right now multiple of these
even though paraprobe-nanochem triggers a number of delocalizations for each of which triggering again isosurfaces
currently the principal idea behind this design is that you normally focus iso-surface-based analyses
on specific elements and for these you may have different discretization and isosurface computation demands
for instance you might be super interested in analyzing in find details the iso-surfaces of carbon in a dataset
but in addition you could be interested also to study chromium iso-surfaces but for completely different iso-contour values
etc. this is what paraprobe-nanochem allows you to do
you create one process for all your carbon related delocalizations, isosurfaces etc
plus another process packing all your chromium delocalization and isosurfaces-->
            <group name="delocalization" type="NXprocess" minOccurs="0" maxOccurs="1">
                <doc>
                     Discretization of the ion point cloud on a three-dimensional grid.
                </doc>
                <field name="input">
                    <doc>
                         Delocalization in the field of atom probe microscopy is the process
                         of discretizing a point cloud. By default the tool computes a full
                         kernel density estimation of decomposed ions to create one discretized
                         field for each element.
                         
                         Although, this uses an efficient multithreaded algorithm,
                         the computation is costly. Therefore, it can be advantageous for users
                         to load an already computed delocalization. This can be achieved with
                         the load_existent option.
                         When using this option the user is responsible to assure that the
                         settings which were used for computing this already existent delocalization
                         are specified in the same manner as they were.
                    </doc>
                    <!--NEW ISSUE: improve UX experience-->
                    <enumeration>
                        <item value="default"/>
                        <item value="load_existent"/>
                    </enumeration>
                </field>
                <!--NEW ISSUE: base class filter-->
                <field name="isotope_whitelist" type="NX_UINT" units="NX_UNITLESS">
                    <doc>
                         Matrix of isotope vectors representing iontypes.
                         The filter specifies a matrix of isotope_vectors which is the most
                         general approach to define if and how many times an ion is counted.
                         Currently, paraprobe_nanochem performs a so-called atomic decomposition
                         of all iontypes. Specifically, the tool interprets of how many
                         elements/atoms a molecular ion is composed; and thus determines the
                         atoms multiplicity with respect to the iontype.
                         
                         Let's take the hydroxonium H3O+ molecular ion as an example:
                         It contains hydrogen and oxygen as atoms. The multiplicity of hydrogen
                         is three whereas that of oxygen is one. Therefore in an atomic
                         decomposition computation of the iso-surface each H3O+ ion adds
                         three hydrogen counts. This is a practical solution which accepts
                         the situation that during an atom probe experiment not each bond
                         of each ion/a group of neighboring atoms is broken but molecular
                         ions get detected. The exact ab-initio details depend on the local
                         field conditions and thus also the detailed spatial arrangement
                         of the atoms and their own electronic state and that of the neighbors
                         before and upon launch.
                         Being able to measure the information for such sites only as
                         molecular ions causes an inherent information loss with respect to the
                         detailed spatial arrangement. This information loss is more relevant
                         for local electrode atom probe than for field ion microscopy setting
                         how precisely the atomic positions can be reconstructed.
                         Accounting for multiplicities assures that at least the
                         compositional information is analyzed.
                    </doc>
                    <dimensions rank="2">
                        <dim index="1" value="n_ityp_deloc_cand"/>
                        <dim index="2" value="n_ivec"/>
                    </dimensions>
                </field>
                <field name="gridresolutions" type="NX_FLOAT" units="NX_LENGTH">
                    <doc>
                         List of individual grid resolutions to analyse.
                         Paraprobe discretizes on a cuboidal 3D grid with cubic cells, with
                         an edge length of values in gridresolutions.
                    </doc>
                </field>
                <!--\@units: nm-->
                <field name="kernel_size" type="NX_UINT" units="NX_UNITLESS">
                    <doc>
                         Half the width of a :math:`{(2 \cdot n + 1)}^3` cubic kernel of voxel
                         beyond which the Gaussian Ansatz function will be truncated.
                         Intensity beyond the kernel is refactored into the kernel via
                         a normalization procedure.
                    </doc>
                </field>
                <field name="kernel_variance" type="NX_FLOAT" units="NX_LENGTH">
                    <doc>
                         Variance of the Gaussian Ansatz kernel :math:`\sigma_x = \sigma_y = 2 \cdot
                         \sigma_z`.
                    </doc>
                </field>
                <!--\@units: nm-->
                <field name="normalization">
                    <doc>
                         How should the results of the kernel-density estimation be computed
                         into quantities. By default the tool computes the total number
                         (intensity) of ions or elements. Alternatively the tool can compute
                         the total intensity, the composition, or the concentration of the
                         ions/elements specified by the white list of elements in each voxel.
                    </doc>
                    <enumeration>
                        <item value="total"/>
                        <item value="candidates"/>
                        <item value="composition"/>
                        <item value="concentration"/>
                    </enumeration>
                </field>
                <field name="has_scalar_fields" type="NX_BOOLEAN">
                    <doc>
                         Specifies if the tool should report the delocalization 3D field values.
                    </doc>
                </field>
                <!--number_of_isosurfaces:
  doc: For now a support field for the tool to identify how many individual analyses the tool should execute during the analysis run.
  unit: NX_UNITLESS-->
                <!--NEW ISSUE: currently isosurface has to be a child of delocalization because otherwise
you could construct the incorrect situation that you leave delocalization optional do not add sth there but fill isosurface
and this does not work because without a delocalization/field quantity you cannot compute iso-surfaces-->
                <group name="isosurfacing" type="NXprocess" minOccurs="0" maxOccurs="1">
                    <doc>
                         Optional computation of iso-surfaces after each computed delocalization
                         to identify for instance objects in the microstructure
                         (line features, interfaces, precipitates).
                    </doc>
                    <field name="edge_handling_method">
                        <doc>
                             As it is detailed in M. Kühbach et al. 2022 npj Comp. Mat.,
                             the handling of triangles at the edge of the dataset requires
                             special attention. Especially for composition-normalized
                             delocalization it is possible that the composition increases
                             towards the edge of the dataset because the quotient of two numbers
                             which are both smaller than one is larger instead of smaller than
                             the counter. By default, the tool uses a modified marching cubes
                             algorithm of Lewiner et al. which detects if voxels face such a
                             situation. In this case, no triangles are generated for such voxels.
                             Alternatively, (via setting keep_edge_triangles) the user can
                             instruct the tool to not remove these triangles at the cost of bias.
                             
                             Specifically, in this case the user should understand that all
                             objects/microstructural features in contact with the edge of the
                             dataset get usually artificial enlarged and their surface mesh
                             often closed during the marching. This closure however is artificial!
                             It can result in biased shape analyses for those objects.
                             The reason why this should in general be avoided is a similar
                             argument as when one analyzes grain shapes in orientation microscopy
                             via e.g. SEM/EBSD. Namely, these grains, here the objects at the
                             edge of the dataset, were not fully captured during e.g. limited
                             field of view.
                             Therefore, it is questionable if one would like to make
                             substantiated quantitative statements about them.
                             
                             Thanks to collaboration with the V. V. Rielli and S. Primig, though,
                             paraprobe-nanochem implements a complete pipeline to
                             process even these objects at the edge of the dataset. Specifically,
                             the objects are replaced by so-called proxies, i.e. replacement
                             objects whose holes on the surface mesh have been closed if possible
                             via iterative mesh and hole-filling procedures with fairing operations.
                             In the results of each paraprobe-nanochem run, these proxy objects
                             are listed separately to allow users to quantify and analyze in
                             detail the differences when accounting for these objects or not.
                             Especially this is relevant in atom probe microscopy as objects
                             can contain a few dozen atoms only.
                             Users should be aware that results from fairing operations should
                             be compared to results from analyses where all objects at the edge
                             of the dataset have been removed.
                             
                             Also users should be careful with overestimating the statistical
                             significance of their dataset especially when using atom probe
                             to compare multiple descriptors: Even though a dataset may give
                             statistically significant results for compositions, this does not
                             necessarily mean it will yield also statistically significant
                             and unbiased results for three-dimensional object analyses.
                             Being able to quantify these effects and making atom probers
                             aware of these subtleties was one of the main reasons why the
                             paraprobe-nanochem tool was implemented.
                        </doc>
                        <enumeration>
                            <item value="default"/>
                            <item value="keep_edge_triangles"/>
                        </enumeration>
                    </field>
                    <field name="edge_threshold" type="NX_FLOAT" units="NX_LENGTH">
                        <doc>
                             The ion-to-edge-distance that is used in the analyses of objects
                             (and proxies) to identify whether these are inside the dataset or
                             close to the edge of the dataset. If an object has at least one ion
                             with an ion-to-edge-distance below this threshold, the object is
                             considered as one which lies close to the edge of the dataset.
                             This implements essentially a distance-based approach to solve
                             the in general complicated and involved treatment of computing
                             volumetric intersections between not-necessarily convex
                             closed 2-manifolds. In fact, such computational geometry analyses
                             can face numerical robustness issues as a consequence of which a
                             mesh can be detected as lying completely inside a dataset although
                             in reality it is epsilon-close only, i.e. almost touching only
                             the edge (e.g. from inside).
                             Practically, humans would state in such case that the object is
                             close to the edge of the dataset; however mathematically the object
                             is indeed completely inside.
                             In short, a distance-based approach is rigorous and more flexible.
                        </doc>
                    </field>
                    <!--\@units: nm-->
                    <field name="phi" type="NX_FLOAT" units="NX_ANY">
                        <doc>
                             Array of iso-contour values. For each value the tool computes
                             an iso-surface and performs subsequent analyses.
                             The unit depends on the choice for the normalization of the
                             accumulated ion intensity values per voxel:
                             
                             * total, total number of ions, irrespective their iontype  
                             * candidates, total number of ions with type in the isotope_whitelist.  
                             * composition, candidates but normalized by composition, i.e. at.-%  
                             * concentration, candidates but normalized by voxel volume, i.e. ions/nm^3
                        </doc>
                    </field>
                    <!--NEW ISSUE: details what these options activate need to be described in more detail !!!!!-->
                    <field name="has_triangle_soup" type="NX_BOOLEAN">
                        <doc>
                             Specifies if the tool should report the triangle soup which represents
                             each triangle of the iso-surface complex.
                             Each triangle is reported with an ID specifying to which triangle
                             cluster (with IDs starting at zero) the triangle belongs.
                             The clustering is performed with a modified DBScan algorithm.
                        </doc>
                    </field>
                    <field name="has_object" type="NX_BOOLEAN">
                        <doc>
                             Specifies if the tool should analyze for each cluster of triangles
                             how they can be combinatorially processed to describe a closed
                             polyhedron. Such a closed polyhedron (not-necessarily convex!)
                             can be used to describe objects with relevance in the microstructure.
                             Users should be aware that the resulting mesh does not necessarily
                             represent the original precipitate. In fact, inaccuracies in the
                             reconstructed positions cause inaccuracies in all downstream
                             processing operations. Especially the effect on one-dimensional
                             spatial statistics like nearest neighbor correlation functions these
                             effects were discussed in the literature 
                             `B. Gault et al. &lt;https://doi.org/10.1017/S1431927621012952&gt;`_ 
                             In continuation of these thoughts this applies also to reconstructed
                             objects. A well-known example is the discussion of shape deviations
                             of Al3Sc precipitates in aluminium alloys which in reconstructions
                             can appear as ellipsoids although they should be almost spherical,
                             depending on their size.
                        </doc>
                    </field>
                    <field name="has_object_geometry" type="NX_BOOLEAN">
                        <doc>
                             Specifies if the tool should report a triangulated surface mesh
                             for each identified closed polyhedron. It is common that a
                             marching cubes algorithm creates iso-surfaces with a fraction of very
                             small sub-complexes (e.g. small isolated tetrahedra).
                             
                             These can be for instance be small tetrahedra/polyhedra about the
                             center of a voxel of the support grid on which marching cubes operates.
                             When these objects are small, it is possible that they contain no ion;
                             especially when considering that delocalization procedures smoothen
                             the positions of the ions. Although these small objects are interesting
                             from a numerical point of view, scientists may argue they are not worth
                             to be reported:
                             Physically a microstructural feature should contain at least a few
                             atoms to become relevant. Therefore, paraprobe-nanochem by default
                             does not report closed objects which bound not at least one ion.
                        </doc>
                    </field>
                    <field name="has_object_properties" type="NX_BOOLEAN">
                        <doc>
                             Specifies if the tool should report properties of each closed
                             polyhedron, such as volume and other details.
                        </doc>
                    </field>
                    <field name="has_object_obb" type="NX_BOOLEAN">
                        <doc>
                             Specifies if the tool should report for each closed polyhedron an
                             approximately optimal bounding box fitted to all triangles of the
                             surface mesh of the object and ion positions inside or on the
                             surface of the mesh.
                             This bounding box informs about the closed object's shape 
                             (aspect ratios).
                        </doc>
                    </field>
                    <!--NEW ISSUE: Addendum Alternatively it is possible to fit triaxial ellipsoids.-->
                    <field name="has_object_ions" type="NX_BOOLEAN">
                        <doc>
                             Specifies if the tool should report for each closed polyhedron
                             all evaporation IDs of those ions which lie inside or on the
                             boundary of the polyhedron. This information can be used e.g.
                             in the paraprobe-intersector tool to infer if two objects share
                             common ions, which can be interpreted as an argument to assume
                             that the two objects intersect.
                             
                             Users should be aware that two arbitrarily closed polyhedra
                             in three-dimensional space can intersect but not share a common ion.
                             In fact, the volume bounded by the polyhedron has sharp edges.
                             When taking two objects, an edge of one object may for instance
                             pierce into the surface of another object. In this case the
                             objects partially overlap / intersect volumetrically; 
                             however this piercing might be so small or happening in the volume
                             between two ion positions and thus sharing ions is a sufficient
                             but not a necessary condition for object intersections.
                             
                             Paraprobe-intersector implements a rigorous alternative to handle
                             such intersections using a tetrahedralization of closed objects.
                             However, in many practical cases, we found through examples that there
                             are polyhedra (especially when they are non-convex and have almost
                             point-like) connected channels, where tetrahedralization libraries
                             have challenges dealing with. In this case checking intersections
                             via shared_ions is a more practical alternative.
                        </doc>
                    </field>
                    <field name="has_object_edge_contact" type="NX_BOOLEAN">
                        <doc>
                             Specifies if the tool should report if a (closed) object has
                             contact with the edge of the dataset. For this the tool currently
                             inspects if the shortest distance between the set of triangles of the
                             surface mesh and the triangles of the edge model is larger than the
                             edge_threshold. If this is the case, the object is assumed to be
                             deeply embedded in the interior of the dataset. Otherwise, the object
                             is considered to have an edge contact, i.e. it is likely affected
                             by the fact that the dataset is finite.
                        </doc>
                    </field>
                    <!--the edge_threshold can be decided based on half the length of the diagonal of the delocalization kernel.
as a consequence of which wider kernels result in larger threshold values causing more objects to become
qualified as having edge contact.-->
                    <field name="has_proxy" type="NX_BOOLEAN">
                        <doc>
                             Specifies if the tool should analyze a doppelganger/proxy mesh for
                             each cluster of triangles whose combinatorial analysis according
                             to has_object showed that the object is not a closed polyhedron.
                             Such proxies are closed via iterative hole-filling, mesh refinement,
                             and fairing operations.
                             Users should be aware that the resulting mesh does not necessarily
                             represent the original precipitate. In most cases objects,
                             like precipitates in atom probe end up as open objects because
                             they have been clipped by the edge of the dataset. Using a proxy is
                             then a strategy to still be able to account for these objects.
                             Nevertheless users should make themselves familiar with the
                             potential consequences and biases which this can introduce
                             into the analysis.
                        </doc>
                    </field>
                    <field name="has_proxy_geometry" type="NX_BOOLEAN">
                        <doc>
                             Like has_object_geometry but for the proxies.
                        </doc>
                    </field>
                    <field name="has_proxy_properties" type="NX_BOOLEAN">
                        <doc>
                             Like has_object_properties but for the proxies.
                        </doc>
                    </field>
                    <field name="has_proxy_obb" type="NX_BOOLEAN">
                        <doc>
                             Like has_object_obb but for the proxies.
                        </doc>
                    </field>
                    <field name="has_proxy_ions" type="NX_BOOLEAN">
                        <doc>
                             Like has_object_ions but for the proxies.
                        </doc>
                    </field>
                    <field name="has_proxy_edge_contact" type="NX_BOOLEAN">
                        <doc>
                             Like has_object_edge_contact but for the proxies.
                        </doc>
                    </field>
                    <field name="has_object_auto_proxigram" type="NX_BOOLEAN">
                        <doc>
                             Specifies if the tool should report for each closed object a 
                             (cylindrical) region of interest placed, centered, and align
                             with the local normal for each triangle of the object.
                        </doc>
                    </field>
                    <field name="has_object_auto_proxigram_edge_contact" type="NX_BOOLEAN">
                        <doc>
                             Specifies if the tool should report for each ROI that was placed
                             at a triangle of each object if this ROI intersects the edge of
                             the dataset. Currently paraprobe-nanochem supports cylindrical
                             ROIs. A possible intersection of these with the edge of the
                             dataset, i.e. the triangulated surface mesh model for the edge
                             is performed. This test checks if the cylinder intersects with
                             a triangle of the surface mesh. If this is the case, the ROI is
                             assumed to make edge contact, else, the ROI is assumed to have
                             no edge contact.
                             
                             This approach does not work if the ROI would be completely
                             outside the dataset. Also in this case there would be
                             no intersection. For atom probe this case is practically
                             irrelevant because for such a ROI there would also be no ion
                             laying inside the ROI. Clearly it has thus to be assumed that
                             the edge model culls the entire dataset. Instead, if one would
                             cut a portion of the dataset, compute an edge model for this
                             point cloud, it might make sense to place a ROI but in this
                             case the edge contact detection is not expected to work properly.
                        </doc>
                    </field>
                </group>
                <!--has_object_mesh_smoothing(NX_BOOLEAN):
 doc: Specifies if the tool should post-process each mesh to improve the mesh quality.
mesh_smoothing(NXprocess):
NEW ISSUE: here we need to specify how the meshes were smoothened
##MK::is this group not at the previous level of the hierarchy?-->
                <group name="interfacial_excess" type="NXprocess" optional="true">
                    <doc>
                         Analyses of interfacial excess.
                    </doc>
                    <field name="interface_model">
                        <doc>
                             Interfacial excess computations are performed for local regions-of-interests
                             (ROIs) at selected facets or interface patch.
                             For instance many scientist compute the interfacial excess for
                             selected triangle facets of a created iso-surface. In this case,
                             computed iso-surfaces of paraprobe could be used. An example are triangle
                             facet sets about closed polyhedra, for instance to compute interfacial
                             excess related to phase boundaries of second-phase precipitates.
                             
                             Another example are free-standing triangle patches of the iso-
                             surfaces which paraprobe creates. These could be characterized
                             for interfacial excess. The sub-routines during iso-surface
                             computations already include a procedure to automatically align
                             local triangle normals based on the gradients of e.g. composition
                             fields. In this case, these triangulated surface patches
                             could also be used as a source for computing interfacial
                             excess.
                             
                             Often scientists face situations, though, in which there is no
                             immediately evident composition gradient across the interface
                             (grain or phase boundary) and orientation information about the
                             adjoining crystal is neither available nor reliable enough.
                             
                             In this case `P. Felfer et al. &lt;https://doi.org/10.1016/j.ultramic.2015.06.002&gt;`_ proposed a method
                             to manually place control points and run an automated tessellation-based
                             algorithm to create a triangulated surface patch, i.e. a model of the
                             location of the interface. In a post-processing step this triangle
                             set can then be used to compute again interfacial excess in an
                             automated manner by placing ROIs and aligning them with
                             consistently precomputed triangle normals.
                             
                             A similar use case is conceptually the one proposed by `X. Zhou et al. &lt;https://doi.org/10.1016/j.actamat.2022.117633&gt;`_
                             They used first a deep-learning method to locate planar triangulated
                             grain boundary patches. These are eventually processed further
                             with manual editing of the mesh via tools like Blender.
                             Once the user is satisfied with the mesh, the computations of interfacial
                             excess reduce again to an automated placing of ROIs, computations
                             of the distributing of ions to respective ROIs and
                             reporting the findings via plotting.
                             
                             Yet another approach for constructing an triangulated surface patch
                             of an interface is to use point cloud processing methods which have
                             been proposed in the laser-scanning, geoinformatics, and CAD community.
                             Different computational geometry methods are available for fitting
                             a parameterized surface to a set of points, using e.g. non-uniform
                             rational B-splines (NURBS) and triangulating these according
                             to prescribed mesh quality demands.
                             
                             The advantage of these methods is that they can be automated and
                             pick up curved interface segments. The disadvantage is their often
                             strong sensitivity to parameterization. As a result also such methods
                             can be post-processed to yield a triangulated surface patch,
                             and thus enable to run again automated ROI placement methods.
                             For example like these which were explored for the use case of
                             iso-surfaces with closed objects and free-standing
                             surface patches that delineate regions of the dataset with a
                             pronounced composition gradient normal to the interface.
                             
                             This summary of the situations which atom probers can face when
                             requesting for interfacial excess computations, substantiates there
                             exists a common set of settings which can describe all of these methods
                             and, specifically, as here exemplified, the automated placing
                             and alignment functionalities for ROIs that is an important
                             step all these workflows.
                             
                             Specifically, paraprobe-nanochem operates on an already existent
                             triangle set.
                        </doc>
                        <enumeration>
                            <item value="isosurface"/>
                            <item value="external"/>
                        </enumeration>
                    </field>
                    <!--NEW ISSUE: how to implement and also check consistently via NeXus that a
NEW ISSUE: child group is required only when a field has a certain value?-->
                    <group name="external" type="NXprocess" optional="true">
                        <doc>
                             The interface model is the result of a previous (set of) processing
                             steps as a result of which the user has created a triangulated
                             surface mesh (or a set of, eventually connected such meshes).
                             These interface models are useful, if not required, in cases when
                             there is no other independent approach to locate an interface.
                             
                             These are cases when insufficient crystallographic latent
                             information is available and also no consistent concentration
                             gradient detectable across the interface. It is then the users'
                             responsibility to deliver a triangle mesh of the interface model.
                        </doc>
                        <field name="file_name">
                            <doc>
                                 Filename to HDF5 file which contain vertex coordinates, facet indices,
                                 facet unit normals. The user is responsible for the triangle
                                 and winding order to be consistent.
                                 Input is expected as a matrix of the coordinates for all disjoint
                                 vertices, a (Nvertices, 3)-shaped array of NX_FLOAT.
                                 Input is expected to include also a matrix of facet indices
                                 referring to these disjoint vertices. This matrix should be a
                                 (Nfacets, 3)-shaped array of NX_UINT. Further required input
                                 is a (Nfacets, 3)-shaped array of NX_FLOAT signed facet unit
                                 normals and a (Nvertices, 3)-shaped array of NX_FLOAT signed
                                 vertex unit normals. Vertex indices need to start at zero and
                                 must not exceed Nvertices - 1, i.e. the identifier_offset is 0
                                 and facet indices are indexed implicitly, i.e. [0, Nvertices-1].
                            </doc>
                            <attribute name="version">
                                <doc>
                                     Version identifier of the file such as a secure hash which
                                     documents the binary state of the file to add an additional
                                     layer of reproducibility from which file specifically
                                     contains these data.
                                </doc>
                            </attribute>
                        </field>
                        <field name="dataset_name_vertices">
                            <doc>
                                 Absolute HDF5 path to the dataset which specifies the
                                 array of vertex positions.
                            </doc>
                        </field>
                        <field name="dataset_name_facet_indices">
                            <doc>
                                 Absolute HDF5 path to the dataset which specifies the
                                 array of facet indices.
                            </doc>
                        </field>
                        <field name="dataset_name_facet_normals">
                            <doc>
                                 Absolute HDF5 path to the dataset which specifies the
                                 array of facet signed unit normals.
                            </doc>
                        </field>
                        <field name="dataset_name_facet_vertices">
                            <doc>
                                 Absolute HDF5 path to the dataset which specifies the
                                 array of vertex signed unit normals.
                                 
                                 Users should be aware that triangulated surface meshes are
                                 only approximations to a given complex, eventually curved shape.
                                 Consequently, computations of normals show differences between
                                 the vertex and facet normals. Vertex normals have to be
                                 interpolated from normals of neighboring facets. Consequently,
                                 these normals are affected by the underlying parameterization
                                 and curvature estimation algorithms, irrespective of how
                                 contributions from neighboring facets are weighted. By contrast,
                                 facet normals are clearly defined by the associated triangle.
                                 Their disadvantage is that they the normal field has discontinuities
                                 at the edges. In general the coarser an object is triangulated
                                 the more significant the difference becomes between computations
                                 based on facet or vertex normals.
                                 Paraprobe-nanochem works with facet normals as it can use 
                                 parts of the numerical performance gained by using cutting
                                 edge libraries to work rather with finer meshes.
                            </doc>
                        </field>
                    </group>
                </group>
            </group>
            <group name="interface_meshing" type="NXprocess" minOccurs="0" maxOccurs="1">
                <doc>
                     Create a simple principle component analysis (PCA) to mesh a
                     free-standing interface patch through a point cloud of decorating solutes.
                     These models can be useful for quantification of Gibbsian
                     interfacial excess for interfaces where iso-surface based methods
                     may fail or closed objects from iso-surfaces are not desired or
                     when e.g. there are no substantial or consistently oriented
                     concentration gradients across the interface patch.
                     
                     The interface_meshing functionality of paraprobe-nanochem can be useful
                     when there is also insufficient latent crystallographic information
                     available that could otherwise support modelling the interface,
                     via e.g. ion density traces in field-desorption maps, as were used and
                     discussed by `Y. Wei et al. &lt;https://doi.org/10.1371/journal.pone.0225041&gt;`_ 
                     or are discussed by `A. Breen et al. &lt;https://github.com/breen-aj/detector&gt;`_
                     
                     It is noteworthy that the method here used is conceptually very similar
                     in implementation to the work by `Z. Peng et al. &lt;https://doi.org/10.1017/S1431927618016112&gt;`_
                     Noteworthy, her team uses the DCOM approach originally proposed by P. Felfer et al.
                     However, both of these previous works neither discuss in detail
                     nor implement inspection functionalities which enable a detection of
                     potential geometric inconsistencies or self-interactions of the
                     resulting DCOM mesh. This is what paraprobe-nanochem implements
                     via the Computational Geometry Algorithms Library.
                </doc>
                <field name="initialization">
                    <doc>
                         Method how to initialize the PCA:
                         
                         * default, means based on segregated solutes in the ROI  
                         * control_point_file, means based on reading an external list of  
                           control points, currently coming from the Leoben APT_Analyzer.  
                         
                         The control_point_file is currently expected with a specific format.
                         The Leoben group lead by L. Romaner has developed a GUI tool `A. Reichmann et al. &lt;https://github.com/areichm/APT_analyzer&gt;`_ 
                         to create a control_point_file which can be parsed by paraprobe-parmsetup
                         to match the here required formatting in control_points.
                    </doc>
                    <enumeration>
                        <item value="default"/>
                        <item value="control_point_file"/>
                    </enumeration>
                </field>
                <field name="filename">
                    <doc>
                         The name of the control point file to use.
                    </doc>
                    <attribute name="version">
                        <doc>
                             Version identifier of the file such as a secure hash which
                             documents the binary state of the file to add an additional
                             layer of reproducibility from which file specifically
                             contains these data.
                        </doc>
                    </attribute>
                </field>
                <field name="control_points" type="NX_FLOAT" units="NX_LENGTH">
                    <doc>
                         X, Y, Z coordinates of disjoint control point read from 
                         an HDF5 file named according to control_point_file.
                    </doc>
                    <!--\@units: nm-->
                    <dimensions rank="2">
                        <dim index="1" value="N"/>
                        <dim index="2" value="n_control_pts"/>
                    </dimensions>
                </field>
                <field name="method">
                    <doc>
                         Method used for identifying and refining the location of the
                         interface. Currently, paraprobe-nanochem implements a PCA followed
                         by an iterative loop of isotropic mesh refinement and DCOM step(s),
                         paired with self-intersection detection in a more robust
                         implementation.
                    </doc>
                    <enumeration>
                        <item value="pca_plus_dcom"/>
                    </enumeration>
                </field>
                <group name="decorating_iontypes_filter" type="NXprocess">
                    <doc>
                         Specify the types of those ions which decorate the interface and
                         can thus be assumed as markers for locating the interface and
                         refining its local curvature.
                    </doc>
                    <field name="candidates" type="NX_UINT" units="NX_UNITLESS">
                        <doc>
                             Array of iontypes to filter. The list is interpreted as a whitelist,
                             i.e. ions of these types are considered the decorating species (solutes).
                        </doc>
                        <dimensions rank="1">
                            <dim index="1" value="n_fct_filter_cand"/>
                        </dimensions>
                    </field>
                </group>
                <field name="number_of_iterations" type="NX_UINT" units="NX_UNITLESS">
                    <doc>
                         How many times should the DCOM and mesh refinement be applied?
                    </doc>
                </field>
                <field name="target_edge_length" type="NX_FLOAT" units="NX_LENGTH">
                    <doc>
                         Array of decreasing positive not smaller than one nanometer real values
                         which specify how the initial triangles of the mesh should be iteratively
                         refined by edge splitting and related mesh refinement operations.
                    </doc>
                    <!--\@units: nm-->
                    <dimensions rank="1">
                        <dim index="1" value="n_fct_iterations"/>
                    </dimensions>
                </field>
                <field name="target_dcom_radius" type="NX_FLOAT" units="NX_LENGTH">
                    <doc>
                         Array of decreasing positive not smaller than one nanometer real values
                         which specify the radius of the spherical region of interest within
                         which the DCOM algorithm decides for each vertex how the vertex will
                         be eventually relocated. The larger the DCOM radius is relative to
                         the target_edge_length the more likely it is that vertices will be
                         relocated so substantially that eventually triangle self-intersections
                         can occur. If the code detects these it warns and stops in a
                         controlled manner so that the user can repeat the analyses
                         with a smaller value.
                    </doc>
                    <!--\@units: nm-->
                    <dimensions rank="1">
                        <dim index="1" value="n_fct_iterations"/>
                    </dimensions>
                </field>
                <field name="target_smoothing_step" type="NX_UINT" units="NX_UNITLESS">
                    <doc>
                         Array of integers which specify for each DCOM step how many times
                         the mesh should be iteratively smoothened.
                         
                         Users should be aware the three array target_edge_length, 
                         target_dcom_radius, and target_smoothing_step are interpreted in the
                         same sequence, i.e. the zeroth entry of each array specifies the
                         values to be used in the first DCOM iteration. The first entry of
                         each array those for the second DCOM iteration and so on and so forth.
                    </doc>
                    <dimensions rank="1">
                        <dim index="1" value="n_fct_iterations"/>
                    </dimensions>
                </field>
            </group>
            <group name="composition_profiling" type="NXprocess" minOccurs="0" maxOccurs="1">
                <doc>
                     Functionalities for placing regions-of-interest (ROIs) in the dataset
                     or at specific microstructural features to characterize composition
                     profiles and cumulated profiles for quantification of interfacial excess.
                     Paraprobe-nanochem currently places cylindrical ROIs. ROIs are probed
                     across the triangulated surface of a user-defined mesh.
                     ROIs are placed at the barycenter of the triangular facet.
                     
                     The tool can be instructed to orient the profile for each ROIs with
                     the positive normal of the triangle facet normals. Profiles are
                     computed for each ROI and facet triangle. The code will test which
                     ROIs are completely embedded in the dataset.
                     Specifically, in this test the tool evaluates if the ROI cuts at least
                     one triangle of the triangulated surface mesh of the edge of the dataset.
                     If this is the case the ROI will be considered close to the edge
                     (of the dataset) and not analyzed further; else the ROI will be
                     processed further.
                     Users should be aware that the latter intersection analysis is strictly
                     speaking not a volumetric intersection analysis as such one is much
                     more involved because the edge model can be a closed non-convex polyhedron
                     in which case one would have to test robustly if the cylinder pierces
                     or is laying completely inside the polyhedron. For this the polyhedron has
                     to be tessellated into convex polyhedra as otherwise tests like the
                     Gilbert-Johnson-Keerthi algorithm would not be applicable.
                     
                     Specifically, the tool computes atomically decomposed profiles.
                     This means molecular ions are split into atoms/isotopes with respective
                     multiplicity. As an example an H3O+ molecular ion contains three
                     hydrogen and one oxygen atom respectively. The tool then evaluates
                     how many ions are located inside the ROI or on the surface of the
                     ROI respectively. All atom types and the unranged ions are distinguished.
                     As a result, the analyses yield for each ROI a set of sorted lists of
                     signed distance values. Currently, the distance is the projected
                     distance of the ion position to the barycenter of the triangle
                     and triangle plane.
                     
                     This will return a one-dimensional profile. Post-processing the set
                     of atom-type-specific profiles into cumulated profiles enable the
                     classical Krakauer/Seidman-style interfacial excess analyses.
                     Furthermore, the tool can be instructed to compute for each
                     (or a selected sub-set of facet) a set of differently oriented profiles.
                </doc>
                <!--In the second case, these profiles will be probed in the direction of
 the outer unit surface normal vectors of a sphere. The sphere is
 discretized via a geodesic sphere (according to ideas of M. Kühbach
 et al. Journal of Applied Crystallography 2021) model with 40962
 directions, some of which are duplicates (for now). This direction
 sampling enables substantially more detailed analyses of the effect
 of aligning the ROI because alignments of ROI based on triangle
 surface normals of the feature mesh can result in larger direction
 differences between neighboring ROIs when the mesh for rough
 surface meshes.-->
                <group name="feature_mesh" type="NXprocess">
                    <doc>
                         The feature mesh enables the injection of previously computed triangle
                         soup or mesh data. Such a mesh can be the model for a grain- or phase
                         boundary patch (from e.g. interface_meshing) jobs.
                    </doc>
                    <field name="filename">
                        <doc>
                             Name of the HDF5 file which contains vertex coordinates and facet
                             indices to describe the desired set of triangles which represents
                             the feature.
                        </doc>
                        <attribute name="version">
                            <doc>
                                 Version identifier of the file such as a secure hash which documents
                                 the binary state of the file to add an additional layer of
                                 reproducibility from which file specifically contains these data.
                            </doc>
                        </attribute>
                    </field>
                    <field name="dataset_name_vertices">
                        <doc>
                             Absolute path to the HDF5 dataset in the respectively specified HDF5
                             file under filename which details the array of vertex positions.
                        </doc>
                    </field>
                    <field name="dataset_name_facet_indices">
                        <doc>
                             Absolute path to the HDF5 dataset in the respective specified HDF5
                             file under filename which details the array of facet indices.
                        </doc>
                    </field>
                    <field name="dataset_name_facet_normals">
                        <doc>
                             Absolute path to the HDF5 dataset in the respective specified HDF5
                             file under filename which details consistently oriented facet
                             normals of the facets.
                        </doc>
                    </field>
                    <!--dataset_name_vertex_normals:
 doc: Absolute path to the HDF5 dataset in the respective specified
 HDF5 file under filename which details consistently oriented
 vertex normals of the facets.
 exists: optional-->
                    <group name="patch_identifier_filter" type="NXmatch_filter" optional="true">
                        <field name="method"/>
                        <field name="match" type="NX_NUMBER"/>
                    </group>
                </group>
                <group name="ion_to_feature_distances" type="NXprocess" optional="true">
                    <doc>
                         The tool enables to inject precomputed distance information for each
                         point which can be used for further post-processing and analysis.
                    </doc>
                    <!--NEW ISSUE: is this optional?-->
                    <field name="filename">
                        <doc>
                             Name of an HDF5 file which contains ion distances.
                        </doc>
                        <attribute name="version">
                            <doc>
                                 Version identifier of the file such as a secure hash which
                                 documents the binary state of the file to add an additional
                                 layer of reproducibility from which file specifically contains
                                 these data.
                            </doc>
                        </attribute>
                    </field>
                    <field name="dataset_name">
                        <doc>
                             Absolute HDF5 path to the dataset with distance values for each ion.
                        </doc>
                    </field>
                </group>
                <field name="distancing_model">
                    <doc>
                         Which type of distance should be reported for the profile.
                    </doc>
                    <enumeration>
                        <item value="project_to_triangle_plane"/>
                    </enumeration>
                </field>
                <!--NEW ISSUE:, ion_to_feature]-->
                <field name="direction_model">
                    <doc>
                         In which directions should the tool probe for each ROI.
                    </doc>
                    <enumeration>
                        <item value="triangle_outer_unit_normal"/>
                    </enumeration>
                </field>
                <!--NEW ISSUE:, angularly_geodesic_sphere]-->
                <field name="roi_cylinder_height" type="NX_FLOAT" units="NX_LENGTH">
                    <doc>
                         For each ROI, how high (projected on the cylinder axis)
                         should the cylindrical ROI be.
                    </doc>
                </field>
                <!--\@units: nm
all ROIs the same height
dimensions:
  rank: 1
  dim: [[1, 1]]-->
                <field name="roi_cylinder_radius" type="NX_FLOAT" units="NX_LENGTH">
                    <doc>
                         For each ROI, how wide (radius) should the cylindrical ROI be.
                    </doc>
                </field>
            </group>
        </group>
        <!--\@units: nm
all ROIs the same radius
dimensions:
  rank: 1
  dim: [[1, 1]]-->
        <group name="performance" type="NXcs_profiling">
            <field name="current_working_directory"/>
        </group>
    </group>
</definition>
