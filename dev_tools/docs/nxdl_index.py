import os
from pathlib import Path
from typing import Dict

import lxml.etree

from ..globals import directories
from ..globals.nxdl import NXDL_NAMESPACE
from ..nxdl import iter_definitions

SOURCE_TO_CATEGORY = {
    "applications": {"alias": "application definitions", "sphx_id": "AppDef"},
    "base_classes": {"alias": "base classes", "sphx_id": "BC"},
    "contributed_definitions": {"alias": "contributed definitions", "sphx_id": "CC"},
}

SOURCE_TO_GROUPING = {
    "applications": ["apm", "diff", "em", "mpes", "optical-spectroscopy", "sas", "tof"],
    "base_classes": [
        "core",
        "tech",
        "sample",
        "computer",
        "danalysis",
        "cg",
        "apm",
        "em",
        "mpes",
        "optical-spectroscopy",
    ],
    "contributed_definitions": [
        "sample",
        "danalysis",
        "cg",
        "apm",
        "optical-spectroscopy",
        "transport",
        "micro",
    ],
}

MOVE_LONG_FLAT_LIST_TO_OWN_GROUP = (
    True  # True for long-flat list in own group, else for legacy support
)


def nxdl_indices(write_rst: bool = True) -> Dict[str, dict]:
    """For each directory under the NXDL root, create the content of an
    index file which link all NeXus class definition doc files.

    write_rst, if true instructs the writing of rst documents with the
    list of all definitions for each respective section (appdefs, classes)
    """
    indentation = " " * 4
    namespaces = {"nx": NXDL_NAMESPACE}
    sections = dict()
    root = directories.get_nxdl_root()

    if MOVE_LONG_FLAT_LIST_TO_OWN_GROUP:
        # apart from groupings for NXDL/XML on specifics topics wish to have index for respective complete-structure.rst
        all_rst_lines: Dict[str, list] = {
            "applications": [],
            "base_classes": [],
            "contributed_definitions": [],
        }
        for source in SOURCE_TO_CATEGORY:
            all_rst_lines[source].append(".. do NOT edit this file\n")
            all_rst_lines[source].append(
                "   automatically generated by dev_tools.docs.nxdl_index\n"
            )
            all_rst_lines[source].append("\n")
            all_rst_lines[source].append(
                f".. _{SOURCE_TO_CATEGORY[source]['sphx_id']}-Complete-Structure:\n"
            )
            all_rst_lines[source].append("\n")
            title = SOURCE_TO_CATEGORY[source]["alias"].title()
            all_rst_lines[source].append(f"{'=' * len(title)}\n")
            all_rst_lines[source].append(f"{title}\n")
            all_rst_lines[source].append(f"{'=' * len(title)}\n")
            all_rst_lines[source].append("\n")
            all_rst_lines[source].append(
                f"This is the complete list of {SOURCE_TO_CATEGORY[source]['alias']}:\n"
            )

    for nxdl_file in iter_definitions():
        source = os.path.relpath(nxdl_file.parent, root)
        section = sections.get(source)
        if section is None:
            preample = _DIRNAME_TO_PREAMBLE.get(source)
            if preample is None:
                continue
            classes = []
            rst_lines = []
            index_file = directories.nxclass_build_root(nxdl_file) / "index.rst"
            sections[source] = {
                "index_file": index_file,
                "rst_lines": rst_lines,
                "classes": classes,
            }
            rst_lines.append(".. do NOT edit this file\n")
            rst_lines.append(f"   automatically generated by {__name__}\n")
            rst_lines.append("\n")
            rst_lines.append(preample)
            rst_lines.append("\n")
            if MOVE_LONG_FLAT_LIST_TO_OWN_GROUP:
                rst_lines.append(
                    f"  :ref:`Complete List <{SOURCE_TO_CATEGORY[source]['sphx_id']}-Complete-Structure>`\n"
                )
            else:
                rst_lines.append(
                    f"The full list of {SOURCE_TO_CATEGORY[source]['alias']}:\n"
                )
            rst_lines.append("\n")
        else:
            classes = sections[source]["classes"]
            rst_lines = sections[source]["rst_lines"]

        nxclass_name = nxdl_file.with_suffix("").stem
        classes.append(nxclass_name)
        summary = get_nxclass_description(nxdl_file, namespaces)
        if MOVE_LONG_FLAT_LIST_TO_OWN_GROUP:
            all_rst_lines[source].append("\n")
            all_rst_lines[source].append(f":ref:`{nxclass_name}`\n")
            all_rst_lines[source].append(f"{indentation}{summary}\n")
        else:  # the legacy long flat list listing all
            rst_lines.append("\n")
            rst_lines.append(f":ref:`{nxclass_name}`\n")
            rst_lines.append(f"{indentation}{summary}\n")

    assert list(sections.keys()) == [
        "applications",
        "base_classes",
        "contributed_definitions",
    ]

    if MOVE_LONG_FLAT_LIST_TO_OWN_GROUP:
        for source in all_rst_lines:
            file_path = (
                directories.manual_build_sphinxroot()
                / "classes"
                / f"{source}"
                / "complete-structure.rst"
            )
            if write_rst:  # when called from pytest build dir might not exist
                with open(file_path, "w") as fh:
                    fh.writelines(all_rst_lines[source])
                print(f"{file_path} written")
        del all_rst_lines

    # Create a table of content for each index file
    for source, section in sections.items():
        # rst_lines is list of rst document for each NXDL/XML
        classes = section.pop("classes")
        rst_lines = section["rst_lines"]
        rst_lines.append("\n")
        rst_lines.append(".. toctree::\n")
        rst_lines.append(f"{indentation}:hidden:\n")
        rst_lines.append("\n")
        if "index_file" in section.keys():
            file = section["index_file"]
            print("----------", file)
            file = os.path.abspath(file)
        else:
            file = ""
            print("---------++++++++-", section)
        if file.endswith(f"{source}/index.rst"):
            for domain in SOURCE_TO_GROUPING[source]:
                rst_lines.append(f"{indentation}{domain}-structure\n")
            # do not forget autogenerated summary
            if MOVE_LONG_FLAT_LIST_TO_OWN_GROUP:
                rst_lines.append(f"{indentation}complete-structure\n")
        for cname in sorted(classes):
            rst_lines.append(f"{indentation}{cname}\n")
    return sections


def get_nxclass_description(nxdl_file: Path, namespaces) -> str:
    """
    get the summary line from each NXDL definition doc

    That's the first physical line of the doc string.
    """
    tree = lxml.etree.parse(nxdl_file)
    root = tree.getroot()
    nodes = root.xpath("nx:doc", namespaces=namespaces)
    if len(nodes) != 1:
        raise RuntimeError(f"wrong number of <doc> nodes in NXDL: {nxdl_file}")
    return nodes[0].text.strip().splitlines()[0]


_DIRNAME_TO_PREAMBLE = {
    "base_classes": """
.. index::
     ! see: class definitions; base class
     ! base class

.. _base.class.definitions:

Base Class Definitions
######################

A description of each NeXus base class definition is given.
NeXus base class definitions define the set of terms that
*might* be used in an instance of that class.
Consider the base classes as a set of *components*
that are used to construct a data file.

A grouping of base classes is offered to assist users with
navigating the full list of base classes along the following topics:

  :ref:`Core Classes <BC-Core-Structure>`

  :ref:`Instrument Components <BC-Tech-Structure>`

  :ref:`Working with Samples <BC-Sample-Structure>`

  :ref:`Working with Computers <BC-Computer-Structure>`

  :ref:`Conventions, Reference Frames, and Data Analysis <BC-Danalysis-Structure>`

  :ref:`Computational and Constructive Solid Geometry <BC-Cgeometry-Structure>`

  :ref:`Atom Probe Microscopy <BC-Apm-Structure>`

  :ref:`Electron Microscopy <BC-Em-Structure>`

  :ref:`Multi-Dimensional Photoemission Spectroscopy <BC-Mpes-Structure>`

  :ref:`Optical Spectroscopy <BC-Opt-Spec-Structure>`
    """,
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    "applications": """
.. index::
     ! see: class definitions; application definition
     ! application definition

.. _application.definitions:

Application Definitions
#########################

A description of each NeXus application definition is given.
NeXus application definitions define the *minimum*
set of terms that
*must* be used in an instance of that class.
Application definitions also may define terms that
are optional in the NeXus data file.  The definition, in this case,
reserves the exact term by declaring its spelling and description.
Consider an application definition as a *contract*
between a data provider (such as the beam line control system) and a
data consumer (such as a data analysis program for a scientific technique)
that describes the information is certain to be available in a data file.

Use NeXus links liberally in data files to reduce duplication of data.
In application definitions involving raw data,
write the raw data in the :ref:`NXinstrument` tree and then link to it
from the location(s) defined in the relevant application definition.

Application definitions are grouped together based on the research fields
where these are typically used. Definitions that address multiple
research fields are listed in each category:

  :ref:`Atom Probe Microscopy <AppDef-Apm-Structure>`

  :ref:`Diffraction Techniques <AppDef-Diff-Structure>`

  :ref:`Electron Microscopy <AppDef-Em-Structure>`

  :ref:`Multi-Dimensional Photoemission Spectroscopy <AppDef-Mpes-Structure>`

  :ref:`Optical Spectroscopy <AppDef-Opt-Spec-Structure>`

  :ref:`Scattering Techniques <AppDef-Sas-Structure>`

  :ref:`Time-of-Flight Techniques <AppDef-Tof-Structure>`
    """,
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    "contributed_definitions": """
.. index::
     ! see: class definitions; contributed definition
     ! contributed definition

.. _contributed.definitions:

Contributed Definitions
#########################

A description of each NeXus contributed definition is given.
NXDL files in the NeXus contributed definitions include propositions from
the community for NeXus base classes or application definitions, as well
as other NXDL files for long-term archival by NeXus. Consider the contributed
definitions as either in *incubation* or a special
case not for general use.  The :ref:`NIAC` is charged to review any new contributed
definitions and provide feedback to the authors before ratification
and acceptance as either a base class or application definition.

These contributions are grouped together based on the research fields
where these are typically used. Definitions that address multiple
research fields are listed in each category:

  :ref:`Working with Samples <CC-Sample-Structure>`

  :ref:`Conventions and Data Analysis <CC-Danalysis-Structure>`

  :ref:`Computational and Constructive Solid Geometry <CC-Cgeometry-Structure>`

  :ref:`Atom Probe Microscopy <CC-Apm-Structure>`

  :ref:`Optical Spectroscopy <CC-Opt-Spec-Structure>`

  :ref:`Transport Measurements <CC-Transport-Structure>`

  :ref:`Microstructures Characterization and Representation <CC-Micro-Structure>`
    """,
}
